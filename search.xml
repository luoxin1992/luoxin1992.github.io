<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Java NIO学习笔记-3]]></title>
      <url>http://www.lx1992.com.cn/2017/09/05/java-nio-3/</url>
      <content type="html"><![CDATA[<p>这是NIO学习笔记的第3篇，也是最后一篇了，还剩下最后一个核心类——Selector，此外会补充一些前面略过的点。</p>
<a id="more"></a>
<h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p>在使用BIO时，为了避免阻塞，我们可能会给每个I/O流开辟一个线程(高端一点，整个线程池啥的)，但大量的线程仍可能占用掉过多的资源。启用NIO中Channel的非阻塞特性吧，上一篇末尾通过死循环来判断结果的逻辑是我不能接受的，甚至也达不到提升性能的目的，这时就需要Selector登场了。</p>
<p>Selector的作用是检查指定的Channel是否有某些的事件发生，比如有数据可以读/写了。如果有，我们才去调用相应的非阻塞方法，通过这种操作规避了在死循环中无意义地调用。</p>
<p>在使用Selector之前，我们需要打开它，并将关注的Channel事件注册给它</p>
<ul>
<li>java.nio.channels.Selector#open</li>
<li>java.nio.channels.SelectableChannel#register(java.nio.channels.Selector, int)</li>
</ul>
<blockquote>
<p>注意：注册给Selector的Channel必须是非阻塞的，否则会抛出java.nio.channels.IllegalBlockingModeException异常</p>
</blockquote>
<p>register方法的第二个int型参数实际上是java.nio.channels.SelectionKey中的常量，共有4个，表明Selector感兴趣的事件(读/写/建立连接/接受连接)</p>
<ul>
<li>java.nio.channels.SelectionKey#OP_READ</li>
<li>java.nio.channels.SelectionKey#OP_WRITE</li>
<li>java.nio.channels.SelectionKey#OP_CONNECT</li>
<li>java.nio.channels.SelectionKey#OP_ACCEPT</li>
</ul>
<blockquote>
<p>注意：一个Selector中可以注册多个Channel，但一个Channel只能在一个Selector里注册一次，第二次及以后的注册只相当于更新SelectionKey</p>
</blockquote>
<p>接着就可以从Selector中选取就绪的Channel了，对应的方法是</p>
<ul>
<li>java.nio.channels.Selector#select()</li>
<li>java.nio.channels.Selector#selectNow</li>
</ul>
<p>两者的区别是前者会阻塞直到至少有一个Channel可以被选中(不一定就绪哦~所以它很有可能返回“0个Channel已就绪”)，而后者是非阻塞的，会立即返回当前就绪的Channel个数，此外select还有一个支持超时的重载版本。</p>
<p>当有Channel就绪以后，通过迭代器迭代下面方法返回的集合，就可以知道当前哪些Channel就绪了</p>
<ul>
<li>java.nio.channels.Selector#selectedKeys</li>
</ul>
<blockquote>
<p>注意：处理过的Channel不会自动从集合中移除，需要手动remove或clear</p>
</blockquote>
<p>再对这些就绪的Channel，用下面的方法判断是否有感兴趣的事件发生</p>
<ul>
<li>java.nio.channels.SelectionKey#isReadable</li>
<li>java.nio.channels.SelectionKey#isWritable</li>
<li>java.nio.channels.SelectionKey#isConnectable</li>
<li>java.nio.channels.SelectionKey#isAcceptable</li>
</ul>
<p>如果有，取出并强制造型相应的Channel作进一步处理</p>
<ul>
<li>java.nio.channels.SelectionKey#channel</li>
</ul>
<p>最后附上一个功能非常简单的非阻塞服务器程序，它使用TCP监听本机8888端口，接受任何传入的连接，不论这个连接向服务器发生什么，都回复当前时间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">public class SelectorDemo &#123;</div><div class="line">    public static void main(String[] args) throws IOException &#123;</div><div class="line">        try (Selector selector = Selector.open();</div><div class="line">             ServerSocketChannel channel = ServerSocketChannel.open()) &#123;</div><div class="line">            channel.bind(new InetSocketAddress(8888));</div><div class="line">            //channel必须是非阻塞的</div><div class="line">            channel.configureBlocking(false);</div><div class="line">            //向selector注册关注的事件</div><div class="line">            channel.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line"></div><div class="line">            while (true) &#123;</div><div class="line">                if (selector.select() == 0) &#123;</div><div class="line">                    //没有channel为ready(能被选中)</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                Iterator&lt;SelectionKey&gt; keys = selector.selectedKeys().iterator();</div><div class="line">                while (keys.hasNext()) &#123;</div><div class="line">                    SelectionKey key = keys.next();</div><div class="line">                    System.out.println(&quot;SELECT: &quot; + key);</div><div class="line"></div><div class="line">                    //处理关注的事件</div><div class="line">                    if (key.isAcceptable()) &#123;</div><div class="line">                        //当前channel已经可以接受连接(那就接受连接呗!)</div><div class="line">                        accept(((ServerSocketChannel) key.channel()).accept(), selector);</div><div class="line">                    &#125;</div><div class="line">                    if (key.isReadable()) &#123;</div><div class="line">                        //当前channel已经可读(读取数据，然后关注写事件)</div><div class="line">                        read((SocketChannel) key.channel());</div><div class="line">                        key.interestOps(SelectionKey.OP_WRITE);</div><div class="line">                    &#125;</div><div class="line">                    if (key.isWritable()) &#123;</div><div class="line">                        //当前channel已经可写(写入数据，然后关注读事件)</div><div class="line">                        write((SocketChannel) key.channel());</div><div class="line">                        key.interestOps(SelectionKey.OP_READ);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    //selectionKey处理完成后要手动从selectedKeys中移除</div><div class="line">                    keys.remove();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void accept(SocketChannel channel, Selector selector) throws IOException &#123;</div><div class="line">        channel.configureBlocking(false);</div><div class="line">        channel.register(selector, SelectionKey.OP_READ);</div><div class="line">        System.out.println(&quot;ACCEPT: &quot; + channel);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void read(SocketChannel channel) throws IOException &#123;</div><div class="line">        ByteBuffer buffer = ByteBuffer.allocate(1024);</div><div class="line"></div><div class="line">        while (channel.read(buffer) &gt; 0) &#123;</div><div class="line">            buffer.flip();</div><div class="line"></div><div class="line">            while (buffer.hasRemaining()) &#123;</div><div class="line">                byte[] bytes = new byte[buffer.remaining()];</div><div class="line">                buffer.get(bytes);</div><div class="line">                System.out.println(&quot;READ: &quot; + new String(bytes, Charset.forName(&quot;utf-8&quot;)));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void write(SocketChannel channel) throws IOException &#123;</div><div class="line">        ByteBuffer buffer = ByteBuffer.allocate(1024);</div><div class="line"></div><div class="line">        String string = new Date().toString();</div><div class="line">        System.out.println(&quot;WRITE: &quot; + string);</div><div class="line"></div><div class="line">        buffer.put(string.getBytes(Charset.forName(&quot;utf-8&quot;)));</div><div class="line">        buffer.flip();</div><div class="line"></div><div class="line">        while (buffer.hasRemaining()) &#123;</div><div class="line">            channel.write(buffer);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Paths和Files"><a href="#Paths和Files" class="headerlink" title="Paths和Files"></a>Paths和Files</h4><p>这两位，是Java7以后新增的工具类，分别用于操作路径和文件，提供类似下面的几个方法</p>
<ul>
<li>java.nio.file.Paths#get(java.lang.String, java.lang.String…)</li>
<li>java.nio.file.Files#copy(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption…)</li>
<li>java.nio.file.Files#move</li>
<li>java.nio.file.Files#delete</li>
<li>……</li>
</ul>
<h4 id="AsynchronousFileChannel"><a href="#AsynchronousFileChannel" class="headerlink" title="AsynchronousFileChannel"></a>AsynchronousFileChannel</h4><p>之前提过，FileChannel是几个常见Channel中唯一一个不支持设置成非阻塞模式的Channel，但某些情况下我们确实有非阻塞操作文件的需求，这该怎么办呢？固然我们可以自己用多线程封装这么一个工具，很可能也已经有三方库实现了类似功能，但Java7以后对此提供了原生的支持——java.nio.channels.AsynchronousFileChannel。</p>
<p>首先依然是打开AsynchronousFileChannel</p>
<ul>
<li>java.nio.channels.AsynchronousFileChannel#open(java.nio.file.Path, java.nio.file.OpenOption…)</li>
</ul>
<p>第2个参数类似于打开RandomAccessFile时的第2个参数，OpenOption的实现类提供了若干个常量表示以读/写等模式打开文件。</p>
<p>随后就可以进行异步的读/写操作了。无论读还是写，都提供2个重载版本</p>
<ul>
<li>java.nio.channels.AsynchronousFileChannel#read(java.nio.ByteBuffer, long)</li>
<li>java.nio.channels.AsynchronousFileChannel#read(java.nio.ByteBuffer, long, A, java.nio.channels.CompletionHandler<java.lang.integer,? super="" a="">)</java.lang.integer,?></li>
<li>java.nio.channels.AsynchronousFileChannel#write(java.nio.ByteBuffer, long)</li>
<li>java.nio.channels.AsynchronousFileChannel#write(java.nio.ByteBuffer, long, A, java.nio.channels.CompletionHandler<java.lang.integer,? super="" a="">)</java.lang.integer,?></li>
</ul>
<p>其中2个参数的方法，返回java.util.concurrent.Future供后期获取执行结果，而4个参数的版本，第4个参数直接是一个java.nio.channels.CompletionHandler类型的、当对文件异步读/写完成的回调。</p>
<p>以读为例，测试代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">private static void readFuture() throws IOException, ExecutionException, InterruptedException &#123;</div><div class="line">    try (AsynchronousFileChannel channel = AsynchronousFileChannel.open(Paths.get(&quot;nio-async-file.txt&quot;), StandardOpenOption.READ)) &#123;</div><div class="line">        ByteBuffer buffer = ByteBuffer.allocate(1024);</div><div class="line">        Future&lt;Integer&gt; future = channel.read(buffer, 0);</div><div class="line">        int length = future.get();</div><div class="line">		//处理读取结果</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static void readCallback() throws IOException &#123;</div><div class="line">    AsynchronousFileChannel channel = AsynchronousFileChannel.open(Paths.get(&quot;nio-async-file.txt&quot;), StandardOpenOption.READ);</div><div class="line">    ByteBuffer buffer = ByteBuffer.allocate(1024);</div><div class="line"></div><div class="line">    channel.read(buffer, 0, null, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public void completed(Integer result, ByteBuffer attachment) &#123;</div><div class="line">            //读取成功回调</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void failed(Throwable exc, ByteBuffer attachment) &#123;</div><div class="line">            //读取失败回调</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分了三部分记的NIO学习笔记暂告一段，可能涉及的内容基本上只是NIO如何使用，没有过多地深入其细节。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java NIO学习笔记-2]]></title>
      <url>http://www.lx1992.com.cn/2017/09/04/java-nio-2/</url>
      <content type="html"><![CDATA[<p>继续NIO部分的内容。上一篇主要介绍了NIO的基本概念，以及Buffer这一NIO核心类的使用，这第二篇我们来看下一个核心类——Channel的使用。</p>
<p>相比BIO中的InputStream、OutputStream，Channel有这么几点不同：</p>
<ul>
<li>BIO中明确了InputStream只能读、OutputStream只能写，而大多数情况下Channel既能读又能写</li>
<li>java.io.InputStream#read()直接返回从流中读到的数据，java.io.OutputStream#write(int)直接将参数中的值写入流，但Channel的读和写都是基于上一篇的Buffer的，而且可以是异步的</li>
</ul>
<a id="more"></a>
<h4 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h4><p>直接看一个例子：用FileChannel简单的读写一个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 写</div><div class="line"> */</div><div class="line">private static void write() throws IOException &#123;</div><div class="line">    try (RandomAccessFile file = new RandomAccessFile(&quot;basic-channel-usage.txt&quot;, &quot;rw&quot;); FileChannel channel = file.getChannel()) &#123;</div><div class="line">        ByteBuffer buffer = ByteBuffer.allocate(32);</div><div class="line"></div><div class="line">        String datetime = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).format(LocalDateTime.now());</div><div class="line">        buffer.put(datetime.getBytes(Charset.forName(&quot;utf-8&quot;)));</div><div class="line"></div><div class="line">        buffer.flip();</div><div class="line">        System.out.println(buffer.remaining() + &quot;字节被写入.&quot;);</div><div class="line"></div><div class="line">        while (buffer.hasRemaining()) &#123;</div><div class="line">            channel.write(buffer);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 读</div><div class="line"> */</div><div class="line">private static void read() throws IOException &#123;</div><div class="line">    try (RandomAccessFile file = new RandomAccessFile(&quot;basic-channel-usage.txt&quot;, &quot;r&quot;); FileChannel channel = file.getChannel()) &#123;</div><div class="line">        ByteBuffer buffer = ByteBuffer.allocate(32);</div><div class="line"></div><div class="line">        while (channel.read(buffer) != -1) &#123;</div><div class="line">            buffer.flip();</div><div class="line">            System.out.println(buffer.remaining() + &quot;字节被读出.&quot;);</div><div class="line"></div><div class="line">            while (buffer.hasRemaining()) &#123;</div><div class="line">                byte[] data = new byte[buffer.remaining()];</div><div class="line">                buffer.get(data);</div><div class="line">                System.out.println(new String(data, Charset.forName(&quot;utf-8&quot;)));</div><div class="line">            &#125;</div><div class="line">            buffer.clear();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在使用FileChannel之前必须打开它(同理，使用之后必须关闭它)，同操作文件、数据库连接等十分相像。获得java.nio.channels.FileChannel有三种方式</p>
<ul>
<li>java.io.FileInputStream#getChannel</li>
<li>java.io.FileOutputStream#getChannel</li>
<li>java.io.RandomAccessFile#getChannel</li>
</ul>
<blockquote>
<p>注意：通过FileInputStream和FileOutputStream获得的Channel只能读/写，强行写/读将抛出java.nio.channels.NonWritableChannelException和java.nio.channels.NonReadableChannelException异常。</p>
</blockquote>
<p>而后，便可使用</p>
<ul>
<li>java.nio.channels.FileChannel#read(java.nio.ByteBuffer)</li>
<li>java.nio.channels.FileChannel#write(java.nio.ByteBuffer)</li>
</ul>
<p>两个方法，结合Buffer对Channel进行读和写，要注意每次操作后Buffer中索引的变化，否则很容易发生不可描述的BUG。</p>
<p>Channel的另一个特性是Scattering Read/Gathering Write，字面上的意思是分散读和集中写，实际使用上就是将一个Channel中的内容读到多个Buffer，或者将多个Buffer的内容写入一个Channel。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 集中写</div><div class="line"> */</div><div class="line">private static void gatheringWrite() throws IOException &#123;</div><div class="line">    try (FileOutputStream stream = new FileOutputStream(&quot;basic-channel-usage.txt&quot;); FileChannel channel = stream.getChannel()) &#123;</div><div class="line">        ByteBuffer[] buffers = new ByteBuffer[4];</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; buffers.length; i++) &#123;</div><div class="line">            buffers[i] = ByteBuffer.allocate(32);</div><div class="line">            buffers[i].put(UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;).getBytes());</div><div class="line">            buffers[i].flip();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        channel.write(buffers);</div><div class="line">        System.out.println(channel.position());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 分散读</div><div class="line"> */</div><div class="line">private static void scatteringRead() throws IOException &#123;</div><div class="line">    try (FileInputStream stream = new FileInputStream(&quot;basic-channel-usage.txt&quot;); FileChannel channel = stream.getChannel()) &#123;</div><div class="line">        ByteBuffer[] buffers = new ByteBuffer[4];</div><div class="line">        for (int i = 0; i &lt; buffers.length; i++) &#123;</div><div class="line">            buffers[i] = ByteBuffer.allocate(32);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        channel.read(buffers);</div><div class="line"></div><div class="line">        for (ByteBuffer buffer : buffers) &#123;</div><div class="line">            buffer.flip();</div><div class="line">            while (buffer.hasRemaining()) &#123;</div><div class="line">                System.out.print((char) buffer.get());</div><div class="line">            &#125;</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>变化比较明显的地方其实只有2行：</p>
<ul>
<li>java.nio.channels.FileChannel#write(java.nio.ByteBuffer[])</li>
<li>java.nio.channels.FileChannel#read(java.nio.ByteBuffer[])</li>
</ul>
<p>它们的参数由上面的单个Buffer变成了一个Buffer数组。对数组中的每一个Buffer，一个Buffer写满/读空后，才会继续下一个写/读Buffer。</p>
<p>最后，FileChannel还有一组其他Channel所不具备的方法</p>
<ul>
<li>java.nio.channels.FileChannel#transferTo</li>
<li>java.nio.channels.FileChannel#transferFrom</li>
</ul>
<p>这两个方法的存在意味着若一次I/O操作中有一方是文件的时候，可以方便地使用这两个方法把数据从一个Channel传输到另一个Channel。因为还没有了解到其他类型的Channel，先用两个FileChannel做示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 转移</div><div class="line"> */</div><div class="line">private static void transfer() throws IOException &#123;</div><div class="line">    try (FileChannel channel1 = new RandomAccessFile(&quot;transfer-fr.txt&quot;, &quot;rw&quot;).getChannel();</div><div class="line">         FileChannel channel2 = new RandomAccessFile(&quot;transfer-to.txt&quot;, &quot;rw&quot;).getChannel()) &#123;</div><div class="line">        channel1.transferTo(0, channel1.size(), channel2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="ServerSocketChannel和SocketChannel"><a href="#ServerSocketChannel和SocketChannel" class="headerlink" title="ServerSocketChannel和SocketChannel"></a>ServerSocketChannel和SocketChannel</h4><p>这两个Channel用于TCP通信，基本的使用方法上与基于BIO的ServerSocket和Socket没有太大的差异。</p>
<p>对ServerSocketChannel而言，首先要打开(open)它，然后将它绑定(bind)到某个Socket地址上，而后它才能接受(accept)传入的连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ServerSocketChannel serverChannel = ServerSocketChannel.open();</div><div class="line">serverChannel.bind(new InetSocketAddress(&quot;localhost&quot;, 8888));</div><div class="line">SocketChannel clientChannel = serverChannel.accept();</div></pre></td></tr></table></figure></p>
<p>对与SocketChannel，更是只需要一步：打开(open)连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SocketChannel channel = SocketChannel.open(new InetSocketAddress(&quot;localhost&quot;, 8888))</div></pre></td></tr></table></figure></p>
<p>无论是服务端还是客户端，取得了SocketChannel的后续操作，同之前的FileChannel就十分相像了，调用下面的2个方法实现读/写。</p>
<ul>
<li>java.nio.channels.SocketChannel#read(java.nio.ByteBuffer)</li>
<li>java.nio.channels.SocketChannel#write(java.nio.ByteBuffer)</li>
</ul>
<h4 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h4><p>有TCP自然就有UDP，作为一种面向无连接、不可靠的协议，它的读/写是通过发送和接收数据报来实现的。不像TCP有复杂的建立连接的过程，使用DatagramChannel之前只需要指明“我想像哪个Socket地址发送数据报”，或者“我想从哪个Socket地址接收数据报”即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 接收</div><div class="line"> */</div><div class="line">private static void receive() throws IOException &#123;</div><div class="line">    try (DatagramChannel channel = DatagramChannel.open()) &#123;</div><div class="line">        ByteBuffer buffer = ByteBuffer.allocate(32);</div><div class="line"></div><div class="line">        channel.socket().bind(new InetSocketAddress(9999));</div><div class="line">        channel.receive(buffer);</div><div class="line">        buffer.flip();</div><div class="line">            </div><div class="line">        while (buffer.hasRemaining()) &#123;</div><div class="line">            System.out.println(buffer.getLong());</div><div class="line">        &#125;</div><div class="line">        buffer.clear();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 发送</div><div class="line"> */</div><div class="line">private static void send() throws IOException &#123;</div><div class="line">    try (DatagramChannel channel = DatagramChannel.open()) &#123;</div><div class="line">        ByteBuffer buffer = ByteBuffer.allocate(32);</div><div class="line">        buffer.putLong(System.currentTimeMillis());</div><div class="line">        buffer.flip();</div><div class="line"></div><div class="line">        while (buffer.hasRemaining()) &#123;</div><div class="line">            channel.send(buffer, new InetSocketAddress(9999));</div><div class="line">        &#125;</div><div class="line">        buffer.clear();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关键的方法就2个</p>
<ul>
<li>java.nio.channels.DatagramChannel#send</li>
<li>java.nio.channels.DatagramChannel#receive</li>
</ul>
<p>但是注意到DatagramChannel中其实也是有read和write方法的。</p>
<ul>
<li>java.nio.channels.DatagramChannel#read(java.nio.ByteBuffer)</li>
<li>java.nio.channels.DatagramChannel#write(java.nio.ByteBuffer)</li>
</ul>
<p>它们的作用是什么呢？上面的Demo是先将Channel的Socket绑定到某个地址再接收数据，或者在发送时才指定发往哪个Socket地址。DatagramChannel亦可以先“连接”到某个地址。</p>
<ul>
<li>java.nio.channels.DatagramChannel#connect</li>
</ul>
<p>随后收发数据都只能面向这个地址，但切记UDP是无连接的，这个connect并不会向TCP那样建立真正的连接，最多只是设置一种绑定关系。</p>
<h4 id="关于非阻塞"><a href="#关于非阻塞" class="headerlink" title="关于非阻塞"></a>关于非阻塞</h4><p>打住！不觉得哪里不对吗？既然是NIO，怎么到目前为止还没有看出哪里体现出非阻塞了……事实上，Channel们既可以仍是阻塞的，也能够通过这个方法并传入参数false，设置成非阻塞的。</p>
<ul>
<li>java.nio.channels.spi.AbstractSelectableChannel#configureBlocking</li>
</ul>
<blockquote>
<p>注意：FileChannel并没有继承至java.nio.channels.spi.AbstractSelectableChannel，也就意味着FileChannel暂时没办法设置成非阻塞的。</p>
</blockquote>
<p>设置成非阻塞以后，再调用曾经的阻塞方法，比如accept，read，write，都将立即返回。我们应当通过判断返回值，来确定刚刚调用的非阻塞方法究竟结果几何。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">try (ServerSocketChannel serverChannel = ServerSocketChannel.open()) &#123;</div><div class="line">    serverChannel.configureBlocking(false);</div><div class="line">    serverChannel.bind(new InetSocketAddress(&quot;localhost&quot;, 8888));</div><div class="line">    System.out.println(&quot;服务端在&quot; + serverChannel.getLocalAddress() + &quot;上监听……&quot;);</div><div class="line"></div><div class="line">    while (true) &#123;</div><div class="line">        try (SocketChannel clientChannel = serverChannel.accept()) &#123;</div><div class="line">            if (clientChannel == null) &#123;</div><div class="line">                System.out.println(&quot;没有连接&quot;);</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            //略</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这样的代码看着都汗……实际上，更多的时候，非阻塞要配合还没有提到的最后一个核心类——Selector一起使用，我们第3篇见。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java NIO学习笔记-1]]></title>
      <url>http://www.lx1992.com.cn/2017/09/04/java-nio-1/</url>
      <content type="html"><![CDATA[<p>Java的NIO，即New I/O，也叫Non-Blocking I/O，作为一个Java 1.4就推出的特性，其实老早就听说了。平时项目中用到的各种Web容器啥的，比方说Tomcat、Jetty，内部都用到了NIO，更别提像Netty这种专门的NIO框架了。最近抽了点时间，对它做了一点简单的了解。</p>
<a id="more"></a>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>首先，NIO包含3个核心的组件，分别是java.nio.<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/Buffer.html" target="_blank" rel="external">Buffer</a>、java.nio.channels.<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/Channel.html" target="_blank" rel="external">Channel</a>和java.nio.channels.<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/Selector.html" target="_blank" rel="external">Selector</a>，即通道、缓冲和选择器。简单地说，数据从通道读入缓冲，或从缓冲写入通道(Channels read data into Buffers, and Buffers write data into Channels)，而选择器用于检测通道的事件。</p>
<p>相比于面向字节或者字符的BIO，在NIO中，一个线程在(发起)从读数据到缓冲区以后，可以去做其他的事，直到读取完成，再回来继续处理，写也是类似的，因而说NIO是非阻塞的。</p>
<p>常见的Channel包括</p>
<ul>
<li>java.nio.channels.FileChannel</li>
<li>java.nio.channels.SocketChannel</li>
<li>java.nio.channels.ServerSocketChannel</li>
<li>java.nio.channels.DatagramChannel</li>
</ul>
<p>从名字上应该不难猜出，它们分别是用于处理文件、TCP和UDP的通道。</p>
<p>常见的Buffer包括</p>
<ul>
<li>java.nio.ByteBuffer</li>
<li>java.nio.CharBuffer</li>
<li>java.nio.DoubleBuffer</li>
<li>java.nio.FloatBuffer</li>
<li>java.nio.IntBuffer</li>
<li>java.nio.LongBuffer</li>
<li>java.nio.ShortBuffer</li>
</ul>
<p>这个看起来比通道更清爽，除去Boolean，其余7种基本数据类型分别有各自对应的缓冲啊哈~此外，ByteBuffer有一个子类MappedByteBuffer，根据API说明，它用于内存到文件的直接映射。</p>
<h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><p>Buffer的本质上就是一块内存区域，示意图如下。图中有3个索引，position、limit和capacity，分别指代下一个<em>要操作</em>的元素的位置、下一个<em>不可操作</em>的元素的位置和Buffer的总长度。此外，我们把limit-position的值记为remaining，意为Buffer中当前剩余元素的个数。</p>
<p><img src="../images/2ba06c5a-dd3d-4b73-8e49-fa33e7a14554.png" alt=""><br>(图源：《深入分析JavaWeb技术内幕(修订版)》，许令波)</p>
<p>首先来创建一个Buffer，以ByteBuffer为例，此时position=0，limit=16，capacity=16，表示缓冲区容量16，接下来操作0号位置，最多可以操作到16号位置(不含)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ByteBuffer buffer = ByteBuffer.allocate(16);</div></pre></td></tr></table></figure></p>
<p>接着往缓冲区里放入三个元素(大写字母A、B、C)，看到position=3，limit和capacity无变化，表明当前缓冲区前3个位置当前已经有数据了。</p>
<p>此外java.nio.ByteBuffer#put(byte)方法还有几个变体，例如java.nio.ByteBuffer#putInt(int)，用于向缓冲区里放其他类型的数据，但如果往缓冲区里放超过其容量个元素，将抛出java.nio.BufferOverflowException。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (int i = &apos;A&apos;; i &lt; &apos;D&apos;; i++) &#123;</div><div class="line">    buffer.put((byte) i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>既然可以用put来放数据，必然就有get来取数据，方法同样有多个，包括java.nio.ByteBuffer#get()、java.nio.ByteBuffer#getInt()等。</p>
<p>且慢！get取出数据的同时，position仍然在往前移动啊！前面我们向Buffer添加了3个元素，如果直接get3次，非但取出的是3个0(position为3、4、5的元素)，还把position移到了6号位置。</p>
<p>所以我们要先调用一下java.nio.Buffer#flip()方法，它的作用是另limit=position，然后使position=0，这样我们既可以重新访问刚才放入Buffer的数据、又不会访问到未使用的位置了(position不能超过limit)，因此有些资料中说这个方法用于“Buffer的读/写”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">buffer.flip();</div><div class="line">//从缓冲区取数据</div><div class="line">for (int i = 0; i &lt; 3; i++) &#123;</div><div class="line">    System.out.println(buffer.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果需要重新读已经读过的Buffer，可以使用java.nio.Buffer#rewind()方法，它只将position复位，不改变limit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">buffer.rewind();</div><div class="line">//又可以愉快地重新读啦</div><div class="line">for (int i = 0; i &lt; 3; i++) &#123;</div><div class="line">    System.out.println(buffer.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>读也读够了，接下来呢？重新把Buffer用在别的地方？那就需要先清除里面旧的东西，使用java.nio.Buffer#clear()方法，它令position=0，limit=capacity，也就是Buffer刚创建出来的样子。注意哦，里边的数据并没有真正被清掉，这和我们删除磁盘文件的道理有点像。</p>
<p>换一种特殊一点的情况，Buffer我们暂时只读了一部分(比方说写入了10字节，先读出5字节)，这时我希望把已经读过的那5个字节的空间让出来。那就需要用java.nio.ByteBuffer#compact()方法“压缩”一下，其原理是1.使用java.lang.System#arraycopy()把Buffer中未读取的数据(position到limit-1部分)复制到Buffer的开头；2.重新设置position=limit-position(即remaining)、limit=capacity。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> //压缩缓冲区</div><div class="line">buffer.compact();</div><div class="line">//清除缓冲区</div><div class="line">buffer.clear();</div></pre></td></tr></table></figure></p>
<p>此外补充一个前面略过的索引——mark，它的初始值是-1，可以调用java.nio.Buffer#mark()方法在当前position处“打个标签”，然后在需要的时候调用java.nio.Buffer#reset()，把position设置到mark过的地方。注意，flip、rewind、clear、compact都会导致mark被自动清除。</p>
<p>这一篇主要就讲讲什么是NIO，以及Buffer相关的东西，其他内容下一篇见~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2018校招——花旗金融信息(一面)]]></title>
      <url>http://www.lx1992.com.cn/2017/08/29/campus-recruiting-cstc-citi-1/</url>
      <content type="html"><![CDATA[<p>时隔近一个月后继续我的秋招(无奈地继续老板的坑……)<br>这回面的不是传统的互联网公司了，作为金融行业，可能风格和套路都有比较大的不同，也导致我整个过程(23分钟)都有几分紧张，但事后照例整理下被问到的问题。</p>
<a id="more"></a>
<p>基础知识部分：</p>
<p>1.介绍项目(三部曲：项目背景/方法/成果)<br>2.在WebSocket出现之前，有哪些技术可以实现与其相似的功能？<br>3.微服务概念的提出？解决的问题？<br>4.微服务如何实现负载均衡？<br>5.Restful概念的提出？和WebService相比解决了什么问题？<br>6.常见的HTTP Method有哪些？PUT和POST的区别，分别什么情况下用？<br>7.HTTPS解决了HTTP什么痛点？如何解决的？(加解密、证书验证)<br>8.对数据可视化有无了解？(我对前端基本空白……)  </p>
<p>简单算法部分：</p>
<p>1.求从0到n的质数，时间复杂度<br>2.一次遍历找到单链表倒数第k个的元素<br>3.散列表的实现原理，增删改查的时间复杂度<br>4.尾递归(××)</p>
<p>数据库部分：</p>
<p>1.如何优化慢查？<br>2.B-树和B+树的区别？索引为什么使用后者？<br>3.分库分表策略设计？</p>
<p>英语能力部分：</p>
<p>1.Could you make a introduction about your university?<br>2.What’s your major? Why do you choose this major?<br>3.Do you have any plan for your career?</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2018校招——蚂蚁金服二面]]></title>
      <url>http://www.lx1992.com.cn/2017/07/20/campus-recruiting-antfin-2/</url>
      <content type="html"><![CDATA[<p>距一面仅过去两天，遂接到二面电话（事实上昨天就打了一次电话，但约的今天面试）。二面用时1小时27分钟，应该算是比较长的了，时间关系，简单整理一下问到的问题。<br><a id="more"></a></p>
<p>项目类：</p>
<ol>
<li>介绍最近的一个项目</li>
<li>如何从PRD转换成设计</li>
<li>UML图的使用</li>
</ol>
<p>架构类：</p>
<ol>
<li>服务部署的方案设计，单机QPS多少，计划布几台机器，如何评估</li>
<li>分布式系统数据一致性的保证，有无预防(不一致的)措施<br>e.g 下游系统双写失败的处理？下游双写成功后上游事务rollback的处理？<br>p.s 了解分布式事务的解决方案</li>
<li>服务间数据同步的时效性如何保证？同步策略的选择</li>
</ol>
<p>技术类(问题1~2有项目背景)：</p>
<ol>
<li>MQ的适用场景</li>
<li>WebSocket的适用场景，对比长连接的优势，从原理上说说两者对性能的影响</li>
<li>MySQL两种存储引擎的差异</li>
<li>MySQL索引的原理及实现，建立索引的注意事项<br>e.g gmt_modify字段可以建索引吗？如何优化根据gmt_modify的查询性能？</li>
<li>Redis的原理，Redis-Cluster实现HA，为什么不直接在本地做缓存</li>
<li>HashMap的内部实现，如何put值<br>e.g. 什么情况下HashMap内会出现多个相同的Key，导致内存溢出<br>(面试官提示：与hashCode方法的实现有关)</li>
<li>自己用反射写过的工具类或者框架，为什么不能反射出方法的参数名<br>p.s 方法签名的构成要件</li>
<li>线程的种类和创建方式，并发的控制</li>
<li>synchronized关键字锁什么，同一个类的多个实例如何用synchronized同步<br>p.s 锁 类名.class 对象</li>
<li>死锁的定义和避免</li>
<li>JVM的内存模型和GC机制，常见的GC算法，分别应用在哪一块内存区域</li>
<li>Java的引用类型，之间有哪些区别</li>
<li>TLS握手的过程，验签的步骤</li>
<li>volatile关键字能用于同步吗  </li>
</ol>
<p>开放型：</p>
<ol>
<li>数据的价值，对大数据的看法</li>
<li>蚂蚁金服可以在哪些方面应用大数据<br>p.s 答支付宝风控，多样化的规则引擎</li>
</ol>
<p>评价：<br>对Java基础，要知其然，知其所以然；推荐你阅读《深入理解Java虚拟机》</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2018校招——蚂蚁金服一面]]></title>
      <url>http://www.lx1992.com.cn/2017/07/18/campus-recruiting-antfin-1/</url>
      <content type="html"><![CDATA[<p>2018年的春招来得比往年都早，这周投了蚂蚁金服内推，刚刚接到一面电话，时长22分钟，简记如下。<br><a id="more"></a></p>
<ol>
<li>介绍实习项目(实习项目采用微服务架构，引出的问题2和3)</li>
<li>(实习项目)微服务的实现，如何做服务发布和服务发现</li>
<li>服务发现以后，服务中心还起哪些作用</li>
<li>事务四特性：ACID(原子性atomicity、一致性consistency、隔离性isolation、持久性durability)</li>
<li>分布式数据库如何实现ACID</li>
<li>分布式ID生成器：SnowFlake算法、唯一性保证、高可用的保证(参考美团Leaf项目)</li>
<li>ArrayList和LinkedList的区别，具体应用场景</li>
<li>hashCode和equals方法</li>
<li>HashMap内部结构，散列冲突的处理(注意JDK8与之前版本实现不一样)，是否线程安全</li>
<li>序列化</li>
<li>JVM内存类型(堆内存、栈帧……)，堆内存类型(持久代、年老代、年轻代)，GC类型(Young GC、Full GC)、GC算法(串行，并行，G1……)、GC方法(引用计数 VS 可达性分析)、GC日志</li>
<li>线程状态及转化</li>
<li>StackOverFlow发生的场景，其他OOM</li>
<li>分库分表的实现，跨库分页</li>
<li>AOP的关键概念，代理模式(JDK动态代理和CgLib代理)</li>
<li>常见加密算法</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[WebSocket基本原理与生命周期]]></title>
      <url>http://www.lx1992.com.cn/2017/06/25/java-web-socket-basic-and-lifecycle/</url>
      <content type="html"><![CDATA[<p>距离上次写博客已经又过去很长一段时间了，这段时间里我一直在做老板的一个项目，而这个项目呢，包括后端、PC客户端和Web管理后台三个部分。其中的PC客户端，因为需要和后端双向通信，所以再用HTTP就不那么和谐了，技术选型的时候考察了下，最后选定了WebSocket。所以这几天打算更新几篇关于Java WebSocket的文章。</p>
<a id="more"></a>
<h4 id="WebSocket简介"><a href="#WebSocket简介" class="headerlink" title="WebSocket简介"></a>WebSocket简介</h4><p>今天上第一篇，先简单说说WebSocket。这货应当算是早有耳闻的，当年本科毕设的时候也需要类似的双向通信，当时也考虑过HTTP长连接，或者类似Comet这种技术(直接走Socket通信就不在考虑范围内了，毕竟太底层了)。</p>
<p>回到WebSocket本身，它是H5中的一项核心技术，实现了客户端和服务端建立起TCP连接之后全双工地通信，连接会一直保活，直到其中一方决定终止连接(也可能因为长时间空闲或者某些非正常因素导致连接断开)，这就避免了每次通信开始前重新建立连接的昂贵代价，也避免了每次获取到许多重复数据的低效率，更实现了服务器主动将数据推送给客户端的特性。</p>
<p>WebSocket协议主要使用2种帧：控制帧和数据帧。其中控制帧用于执行一些协议内部功能逻辑，又分为3种：Close、Ping和Pong，Close即请求关闭连接，Ping-Pong看起来天生一对，常被用于心跳检测；数据帧携带了应用程序数据，主要分为2大类：Text和Binary，顾名思义，前者携带文本消息，后者携带二进制消息，另外注意数据帧可以是完整的(Whole)，也可以是部分的(Partial)。</p>
<p>Java EE 7开始提供的WebSocket相关的API，可以参考<a href="http://www.oracle.com/technetwork/cn/articles/java/jsr356-1937161-zhs.html" target="_blank" rel="external">JSR 356</a>。</p>
<h4 id="实现Echo服务端"><a href="#实现Echo服务端" class="headerlink" title="实现Echo服务端"></a>实现Echo服务端</h4><p>要实现WebSocket服务端(以一个简单的Echo服务为例)，有两种方式，一种是注解式，另一种是编程式(似曾相识啊……)。</p>
<p>注解式类似这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@ServerEndpoint(&quot;/annotation/echo&quot;)</div><div class="line">public class AnnotationEchoServer &#123;</div><div class="line">	@OnMessage</div><div class="line">	public String echo(String message) &#123;</div><div class="line">		return message;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里用到2个注解，@ServerEndpoint注解在类上，它告诉Web容器，这个类是一个服务器“端点”(即WebSocket通信的一端)，连接它的URI是“/echo”；而@OnMessage注解在方法上，表明这个方法将处理OnMessage这个WebSocket事件(具体的在下文“生命周期”中展开)，即这个方法将处理这个端点的入站消息，处理的方法是将收到的消息原封不动的再发送回去(即Echo)，</p>
<p>而编程式写法则是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class ProgrammaticEchoServerConfig implements ServerApplicationConfig &#123;</div><div class="line">	@Override</div><div class="line">	public Set&lt;Class&lt;?&gt;&gt; getAnnotatedEndpointClasses(Set&lt;Class&lt;?&gt;&gt; arg0) &#123;</div><div class="line">		return arg0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Set&lt;ServerEndpointConfig&gt; getEndpointConfigs(Set&lt;Class&lt;? extends Endpoint&gt;&gt; arg0) &#123;</div><div class="line">		Set&lt;ServerEndpointConfig&gt; configs = new HashSet&lt;&gt;();</div><div class="line">		ServerEndpointConfig config = ServerEndpointConfig.Builder</div><div class="line">				.create(ProgrammaticEchoServer.class, &quot;/programmatic/echo&quot;).build();</div><div class="line">		configs.add(config);</div><div class="line">		return configs;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class ProgrammaticEchoServer extends Endpoint &#123;</div><div class="line">	private Session session;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onOpen(Session session, EndpointConfig endpointConfig) &#123;</div><div class="line">		this.session = session;</div><div class="line">		session.addMessageHandler(String.class, message -&gt; &#123;</div><div class="line">			try &#123;</div><div class="line">				this.session.getBasicRemote().sendText(message);</div><div class="line">			&#125; catch (IOException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码要长了不少……这里涉及2个类，配置类ProgrammaticEchoServerConfig实现了ServerApplicationConfig接口，接口中的2个方法分别是Web容器启动时扫描到的注解式端点和编程式端点的类的实例，这里我们只关心编程式端点，并为其指定了URI——“/programmatic/echo”；</p>
<p>另一个类是端点的实现类ProgrammaticEchoServer，它继承自Endpoint，有一个抽象方法onOpen用于处理客户端连接事件，我们需要在每一个连接上的Session添加MessageHandler(即说明如何处理收到的各类消息)，这里处理的方式和注解式端点中的处理是一样的。要通过已知的Session向会话的另一方发送消息，需要RemoteEndpoint对象，这个对象又分为两种，Basic和Async——一个是同步的，一个是异步的。</p>
<h4 id="实现Echo客户端"><a href="#实现Echo客户端" class="headerlink" title="实现Echo客户端"></a>实现Echo客户端</h4><p>仅有服务端当然是不能建立通讯的，我们还要看看客户端怎么做，功能上嘛：实现当连接建立的时候向服务端发送本机系统时间，并接收服务端的Echo，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line">import java.net.URI;</div><div class="line">import java.net.URISyntaxException;</div><div class="line">import java.time.LocalDateTime;</div><div class="line">import java.time.format.DateTimeFormatter;</div><div class="line">import java.time.format.FormatStyle;</div><div class="line"></div><div class="line">import javax.websocket.ClientEndpoint;</div><div class="line">import javax.websocket.CloseReason;</div><div class="line">import javax.websocket.ContainerProvider;</div><div class="line">import javax.websocket.DeploymentException;</div><div class="line">import javax.websocket.OnMessage;</div><div class="line">import javax.websocket.OnOpen;</div><div class="line">import javax.websocket.SendHandler;</div><div class="line">import javax.websocket.SendResult;</div><div class="line">import javax.websocket.Session;</div><div class="line">import javax.websocket.WebSocketContainer;</div><div class="line"></div><div class="line">@ClientEndpoint</div><div class="line">public class EchoClient &#123;</div><div class="line">	private Session session;</div><div class="line"></div><div class="line">	@OnOpen</div><div class="line">	public void onOpen(Session session) &#123;</div><div class="line">		this.session = session;</div><div class="line">		System.out.println(&quot;Server Connect: &quot; + session.getId());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@OnMessage</div><div class="line">	public void onMessage(String message) &#123;</div><div class="line">		System.out.println(&quot;Client receive: &quot; + message);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void connectServer() throws DeploymentException, IOException, URISyntaxException &#123;</div><div class="line">		WebSocketContainer container = ContainerProvider.getWebSocketContainer();</div><div class="line">		container.connectToServer(this, new URI(&quot;ws://localhost:8080/websocket-server/programmatic/echo&quot;));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void sendMessage() &#123;</div><div class="line">		String message = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).format(LocalDateTime.now());</div><div class="line">		this.session.getAsyncRemote().sendText(message, new SendHandler() &#123;</div><div class="line">			public void onResult(SendResult result) &#123;</div><div class="line">				if (result.isOK()) &#123;</div><div class="line">					System.out.println(&quot;Client send: &quot; + message);</div><div class="line">				&#125; else &#123;</div><div class="line">					System.out.println(&quot;Client Error: &quot; + result.getException().getMessage());</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws Exception &#123;</div><div class="line">		EchoClient echoClient = new EchoClient();</div><div class="line">		echoClient.connectServer();</div><div class="line">		echoClient.sendMessage();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>特别注意，JSR 356提供的只是WebSocket的接口，并没有具体的实现，因此如果遇到这样的错误并不奇怪</p>
<blockquote>
<p>Exception in thread “main” java.lang.RuntimeException: Could not find an implementation class.<br>    at javax.websocket.ContainerProvider.getWebSocketContainer(ContainerProvider.java:73)</p>
</blockquote>
<p>解决的方法是引入包含JSR 356实现的jar包，Jetty、Glassfish等Web容器均提供了类似实现。</p>
<h4 id="WebSocket连接的建立过程"><a href="#WebSocket连接的建立过程" class="headerlink" title="WebSocket连接的建立过程"></a>WebSocket连接的建立过程</h4><p>WebSocket连接的建立过程仍然是基于一次特殊的HTTP请求/响应，这个过程称为“握手”，我们可以通过Charles或其他同类抓包工具简单看一下这个过程。客户端的请求(部分)和服务端的响应(部分)分别如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET /websocket-server/annotation/echo HTTP/1.1</div><div class="line">Sec-WebSocket-Version: 13</div><div class="line">Sec-WebSocket-Extensions: permessage-deflate</div><div class="line">Sec-WebSocket-Key: S16Xokvx3+n8xHbqfV5FOA==</div><div class="line">Upgrade: websocket</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 </div><div class="line">Upgrade: websocket</div><div class="line">Connection: upgrade</div><div class="line">Sec-WebSocket-Accept: Q5dJ+WYxjdu4hkPWZasBIXhwxh4=</div><div class="line">Sec-WebSocket-Extensions: permessage-deflate</div></pre></td></tr></table></figure>
<p>可以看到客户端仍然是发起了一个HTTP请求，只不过在Header中要求升级(Upgrade)到WebSocket协议，这个请求头在HTTP升级HTTPS时也会见到；服务端则给出了101状态码，该状态码表示协议切换成功；至于其他Header，表示的是这次连接关于安全性、子协议、扩展的方面的参数。</p>
<h4 id="WebSocket生命周期"><a href="#WebSocket生命周期" class="headerlink" title="WebSocket生命周期"></a>WebSocket生命周期</h4><p>与其说WebSocket的生命周期，不如认为是WebSocket连接存续期间可能发生的事件，分为打开、消息、错误、关闭4种。</p>
<p>“打开”永远是第一个生命周期事件，它用于指示到另一端的连接已经建立；打开事件之后，参与通信的双方就可以互相发送消息了，双方的每一次对话都会触发“消息”事件；对话过程中可能发生各种错误，此时将触发“错误”事件，错误可能是致命的(导致连接关闭)，也可能只是导致这次会话不能被正确处理；最后，当一端决定结束会话，将产生“关闭”事件。</p>
<p>这些事件可以一对一地映射到Java API中，对应注解式写法是以下4个注解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@ServerEndpoint(&quot;/annotation/echo&quot;)</div><div class="line">public class AnnotationEchoServer &#123;</div><div class="line">	@OnOpen</div><div class="line">	public void onOpen(Session session, EndpointConfig config) &#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@OnMessage</div><div class="line">	public void onMessage(Session session, String message) &#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@OnError</div><div class="line">	public void onError(Session session, Throwable throwable) &#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@OnClose</div><div class="line">	public void onClose(Session session, CloseReason reason) &#123;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而编程式写法则是这么3个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public abstract class Endpoint &#123;</div><div class="line">    public abstract void onOpen(Session session, EndpointConfig config)；</div><div class="line">    </div><div class="line">    public void onClose(Session session, CloseReason closeReason) &#123;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void onError(Session session, Throwable thr) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中的@OnOpen注解和onOpen方法等，在前边已经有出现过。另外注意注解式写法中，4个方法的参数类型、顺序等都不是唯一的，具体用法可以参考<a href="https://docs.oracle.com/javaee/7/api/javax/websocket/package-summary.html" target="_blank" rel="external">API文档</a>。</p>
<p>此外，WebSocket编程模型与HTTP(Servlet)还有一点重大差异，那就是WebSocket实现内部提供了“同一个连接不会在同一时间被多个事件线程调用”的保证，这是不是就意味着我们在开发的时候不需要考虑这方面的并发了？</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java.util.Properties踩坑记]]></title>
      <url>http://www.lx1992.com.cn/2017/05/13/stepped-pit-into-java-util-properties/</url>
      <content type="html"><![CDATA[<p>刚刚掉进java.util.Properties的坑里了……其实也好久没记博客了。java.util.Properties这个类继承至java.util.Hashtable&lt;Object, Object&gt;，常用来表示一些属性。<br><a id="more"></a></p>
<p>问题发生在配置某个三方库上，其中有一处参数传入的正是若干属性包装成的Properties。鉴于它继承了Hashtable中的所有方法，我想当然地用了<code>java.util.Hashtable#put(java.lang.Object, java.lang.Object)</code>方法往里面放属性(碰巧属性值既有String类型，又有int、boolean类型，这个方法太和我意了～)，而后项目启动时就抛出了空指针。</p>
<p>StackTrace显示出问题的地方是这个三方库从Properties中取出配置参数的几行代码，但是DEBUG看，Properties中各个属性都准确无误，进一步单步，发现了“神奇”的问题——一个明明存在的属性在<code>java.util.Properties#getProperty(java.lang.String)</code>时居然是null？！</p>
<p>问题就出在这个getProperty方法上，下面是它的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public String getProperty(String key) &#123;</div><div class="line">    Object oval = super.get(key);</div><div class="line">    String sval = (oval instanceof String) ? (String)oval : null;</div><div class="line">    return ((sval == null) &amp;&amp; (defaults != null)) ? defaults.getProperty(key) : sval;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到第3行这里，如果取出的属性值不是String类型，那么就将它置为null。虽然我不太理解为什么这样设计，但至少是吸取了一个教训，往Properties里放属性应当使用<code>java.util.Properties#setProperty(java.lang.String, java.lang.String)</code>方法，虽然它直接调用的还是父类的put方法，也就是让我掉坑里的那家伙，但人家通过形参限制了key、value都只能是String。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java8学习之新的日期和时间API]]></title>
      <url>http://www.lx1992.com.cn/2017/02/16/java8-the-new-date-and-time-api/</url>
      <content type="html"><![CDATA[<p>过去，在Java中处理日期和时间时，无外乎这两个类(以及它们的子类)</p>
<ul>
<li>java.util.Date</li>
<li>java.util.Calendar</li>
</ul>
<p>但它们固有一些缺陷，到了Java8，我们有了更多更好的选择，包括又不限于</p>
<ul>
<li>java.time.Instant</li>
<li>java.time.Duration</li>
<li>java.time.format.DateTimeFormatter</li>
</ul>
<a id="more"></a>
<h4 id="绝对时间"><a href="#绝对时间" class="headerlink" title="绝对时间"></a>绝对时间</h4><p>如果我们把时间看做一道长河（时间轴），那么其上的每一个<em>点</em>，就是一个<em>瞬间</em>(Instant)，用java.time.Instant类的对象表示。Instant类可以表示的时间范围非常之广，从-1000000000-01-01 00:00:00到+1000000000-12-31 23:59:59.999999999，和先前的java.util.Date类似，仍然取1970-01-01 00:00:00作为时间的纪元，这3个特殊的时间点，可以通过Instant.MIN，Instant.MAX和Instant.EPOCH加以验证。若要取得当前的瞬时值，可以使用<em>now</em>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获得Instant可以表示的最小、最大时间点</span></div><div class="line">Instant min = Instant.MIN;</div><div class="line">Instant max = Instant.MAX;</div><div class="line">System.out.println(min);</div><div class="line">System.out.println(max);</div><div class="line"><span class="comment">//获取Instant时间纪元和当前时间点</span></div><div class="line">Instant epoch = Instant.EPOCH;</div><div class="line">Instant now = Instant.now();</div><div class="line">System.out.println(epoch);</div><div class="line">System.out.println(now);</div></pre></td></tr></table></figure></p>
<p>两个Instant之间的距离，被称为<em>持续时间</em>(Duration)，要计算Duration，使用<em>between</em>方法，然后再通过<em>toNanos|Seconds|Days</em>等方法得到这段时间对应的，从纳秒到天，不同精度的表示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//计算两个Instant之间的Duration</span></div><div class="line">Duration duration = Duration.between(epoch, now);</div><div class="line">System.out.println(duration);</div><div class="line">System.out.println(duration.toMillis());</div><div class="line">System.out.println(duration.toDays());</div></pre></td></tr></table></figure></p>
<p>无论是Instant对象还是Duration对象，它们都是不可变的，底层分实际上由一个long型和一个int型整数组成，前者表示这个时间点距离时间纪元的<em>秒</em>数，后者表示一个最多可以精确到纳秒的调整值，注意这里已经不再是距离时间纪元的<em>毫秒</em>数了。</p>
<p>此外，二者均提供了诸多数学操作，即包括了做四则运算的<em>plus|minus[Nanos|Seconds|Days]</em>、<em>multiplied|dividedBy</em>，也有类似<em>abs</em>、<em>isZero|Negative</em>这样的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对Instant和Duration进行数学操作</span></div><div class="line">Instant nowPlusDays = now.plus(<span class="number">1</span>, ChronoUnit.DAYS);</div><div class="line">System.out.println(nowPlusDays);</div><div class="line">Instant nowMinusSeconds = now.minusSeconds(<span class="number">86400</span>);</div><div class="line">System.out.println(nowMinusSeconds);</div><div class="line">Duration durationMultiplyFactor = duration.multipliedBy(<span class="number">3</span>);</div><div class="line">System.out.println(durationMultiplyFactor.toMillis());</div><div class="line">Duration durationDivideFactor = duration.dividedBy(<span class="number">2</span>);</div><div class="line">System.out.println(durationDivideFactor.toMillis());</div><div class="line">System.out.println(duration.isNegative());</div></pre></td></tr></table></figure></p>
<h4 id="本地日期-时间"><a href="#本地日期-时间" class="headerlink" title="本地日期/时间"></a>本地日期/时间</h4><p>Java8提供了LocalDate、LocalTime、LocalDateTime这么3个类来表示本地日期/时间。用这3个类所表示的时间，是无法对应在Instant上的，主要原因是它缺少了时区等信息，也就无法准确地与一个瞬时点对应起来。</p>
<p>可以使用<em>now</em>、<em>of</em>方法构造LocalDate、LocalTime、LocalDateTime对象，先前Date类的几个奇怪设计：月份取值0-11、年份是目标年份与1900之差等都不复存在了，而且类似于Instant和Duration，提供了<em>plus|minus[Days|Weeks|Months|Years]</em>等方法可用于数学计算。此外，两个LocalDateTime只差不再是Duration，而是<em>时段</em>(Period)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//构造本地日期/时间</span></div><div class="line">LocalDate nowDate = LocalDate.now();</div><div class="line">LocalTime nowTime = LocalTime.now();</div><div class="line">LocalDateTime ofDateTime = LocalDateTime.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">System.out.println(nowDate);</div><div class="line">System.out.println(nowTime);</div><div class="line">System.out.println(ofDateTime);</div><div class="line"><span class="comment">//数学计算</span></div><div class="line">LocalDate nowDateMinusYears = nowDate.minusYears(<span class="number">1</span>);</div><div class="line">System.out.println(nowDateMinusYears);</div><div class="line">System.out.println(nowDateMinusYears.isLeapYear());</div><div class="line"><span class="comment">//计算两个LocalDateTime之间的Period</span></div><div class="line">LocalDate springFestival = LocalDate.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">LocalDate nationalDay = LocalDate.of(<span class="number">2017</span>, <span class="number">10</span>, <span class="number">1</span>);</div><div class="line">Period period = springFestival.until(nationalDay);</div><div class="line">System.out.println(period);</div><div class="line"><span class="keyword">long</span> periodInDays = springFestival.until(nationalDay, ChronoUnit.DAYS);</div><div class="line">System.out.println(periodInDays);</div></pre></td></tr></table></figure></p>
<p>如果要获取/设置已经用LocalDate、LocalTime、LocalDateTime表示的某个时间中某个字段(如：年、月、日、时、分、秒)的值，对应的也有<em>get|withYear|Minute</em>等方法(略好奇为什么设置不是set而是with……)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//字段值操作</span></div><div class="line">Month month = nowDate.getMonth();</div><div class="line">DayOfWeek dayOfWeek = nowDate.getDayOfWeek();</div><div class="line">System.out.println(month);</div><div class="line">System.out.println(dayOfWeek);</div><div class="line">LocalTime withTime = nowTime.withHour(<span class="number">0</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>).withNano(<span class="number">0</span>);</div><div class="line">System.out.println(withTime);</div></pre></td></tr></table></figure></p>
<p>对LocalDate而言，<em>with</em>方法还有一种特殊的用法，就是通过<em>日期校正器</em>(TemporalAdjusters)，直接计算出<em>first|lastDayOf(Next)Month|Year</em>(今年/本月/次月/明年的第一天/最后一天)、<em>first/last/dayOfweekInMonth</em>(本月中的第一个/最后一个/第X个星期X)、<em>next|previous(OrSame)</em>(下一个/上一个(或同一个)星期X)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用TemporalAdjusters</span></div><div class="line">LocalDate aDate = LocalDate.of(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">1</span>);</div><div class="line">LocalDate firstDayOfNextMonth = aDate.with(TemporalAdjusters.firstDayOfNextMonth());</div><div class="line">LocalDate lastDayOfYear = aDate.with(TemporalAdjusters.lastDayOfYear());</div><div class="line">LocalDate firstFridayInMonth = aDate.with(TemporalAdjusters.firstInMonth(DayOfWeek.FRIDAY));</div><div class="line">LocalDate nextOrSameWednesday = aDate.with(TemporalAdjusters.nextOrSame(DayOfWeek.WEDNESDAY));</div><div class="line">LocalDate previousWednesday = aDate.with(TemporalAdjusters.previous(DayOfWeek.WEDNESDAY));</div><div class="line">System.out.println(firstDayOfNextMonth);</div><div class="line">System.out.println(lastDayOfYear);</div><div class="line">System.out.println(firstFridayInMonth);</div><div class="line">System.out.println(nextOrSameWednesday);</div><div class="line">System.out.println(previousWednesday);</div></pre></td></tr></table></figure></p>
<h4 id="带时区的日期时间"><a href="#带时区的日期时间" class="headerlink" title="带时区的日期时间"></a>带时区的日期时间</h4><p>虽说时区完全就是一个人为的概念，但带有时区的时间反而更符合实际情况，Java8用ZonedDateTime来表示这种时间。</p>
<p>首先，它可以和LocalDateTime一样直接构造出来，无非是多了一个表示时区ZoneId作为参数。其次，它也可以从LocalDateTime转化而来，或者转化为LocalDateTime，用的是<em>LocalDateTime#atZone</em>和<em>ZonedDateTime#toLocalDateTime</em>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">LocalDateTime localDateTime = LocalDateTime.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">ZonedDateTime fromLocalDateTime = localDateTime.atZone(ZoneId.of(<span class="string">"UTC"</span>));</div><div class="line">System.out.println(fromLocalDateTime);</div><div class="line">ZonedDateTime ofZonedDateTime = ZonedDateTime.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ZoneId.of(<span class="string">"UTC"</span>));</div><div class="line">System.out.println(ofZonedDateTime);</div><div class="line">LocalDateTime toLocalDateTime = ofZonedDateTime.toLocalDateTime();</div><div class="line">System.out.println(toLocalDateTime);</div></pre></td></tr></table></figure></p>
<p>ZonedDateTime和上面其他所有类一样，也提供了非常多用于数学计算的方法，当然由于涉及时区、夏令时等的计算，应当在实现上会更复杂，不过在中国很少开发涉及这些的程序，我也就没有过多去关注了。</p>
<h4 id="格式化和解析"><a href="#格式化和解析" class="headerlink" title="格式化和解析"></a>格式化和解析</h4><p>个人觉得格式化和解析这一段同以前的java.text.DateFormat和java.text.SimpleDateFormat类似乎没有太大的变化，同样可以把一个日期/时间做/从3种不同形式的格式化/解析，分别是标准格式、本地化格式和自定义格式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">LocalDateTime now = LocalDateTime.now();</div><div class="line"><span class="comment">//标准格式</span></div><div class="line">String isoLocalDateTime = DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(now);</div><div class="line">System.out.println(isoLocalDateTime);</div><div class="line"><span class="comment">//本地化格式</span></div><div class="line">String fullLocalizedDateTime = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).format(now);</div><div class="line">System.out.println(fullLocalizedDateTime);</div><div class="line"><span class="comment">//自定义格式</span></div><div class="line">String patternDateTime = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>).format(now);</div><div class="line">System.out.println(patternDateTime);</div><div class="line"><span class="comment">//解析</span></div><div class="line">ZonedDateTime zonedDateTime = ZonedDateTime.parse(<span class="string">"2017-01-01T00:00:00.000+08:00[Asia/Shanghai]"</span>,DateTimeFormatter.ISO_ZONED_DATE_TIME);</div><div class="line">System.out.println(zonedDateTime);</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java8学习之Stream API]]></title>
      <url>http://www.lx1992.com.cn/2017/02/09/java8-the-stream-api/</url>
      <content type="html"><![CDATA[<p>Java8在集合框架中添加了Stream API。Stream API的作用也是处理集合中的元素，但和传统的迭代器相比，应该说在性能上更具优势。Stream的使用分成3个步骤。</p>
<ol>
<li>创建一个Stream</li>
<li>描述要做什么，即指定一个或多个将一个Stream转化为另一个Stream的<em>中间操作</em></li>
<li>要求产生结果，即使用<em>终止操作</em><a id="more"></a>
</li>
</ol>
<h4 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h4><p>Java8中，不单是所有集合的实现均提供了stream()方法，常用的还包括：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//使用Collection接口的stream方法</div><div class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">list.add(&quot;Hello World&quot;);</div><div class="line">Stream&lt;String&gt; stream1 = list.stream();</div><div class="line"></div><div class="line">//使用Stream.of静态创建流</div><div class="line">Stream&lt;String&gt; stream2 = Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;);</div><div class="line"></div><div class="line">//从数组转换Stream</div><div class="line">String[] array = new String[]&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;&#125;;</div><div class="line">Stream&lt;String&gt; stream3 = Arrays.stream(array);</div><div class="line"></div><div class="line">//创建空的Stream</div><div class="line">Stream&lt;String&gt; stream4 = Stream.empty();</div><div class="line"></div><div class="line">//创建无限长度的Stream(含有无限多个随机数)</div><div class="line">Stream&lt;Double&gt; stream5 = Stream.generate(Math::random);</div><div class="line"></div><div class="line">//创建无限长度的Stream(含有无穷递增数列)</div><div class="line">Stream&lt;Integer&gt; stream6 = Stream.iterate(0, (val) -&gt; val + 1);</div></pre></td></tr></table></figure></p>
<p>也就是说，除了从集合转换，我们还可以静态创建，甚至直接生成可能长度都是无限的Stream。但是，Stream本身并不存储其中的元素，这也就是为什么可以有长度无限的Stream，真正的存储依赖其底层集合，或者动态产生。</p>
<h4 id="Stream的中间操作"><a href="#Stream的中间操作" class="headerlink" title="Stream的中间操作"></a>Stream的中间操作</h4><p>常用的Stream中间操作包括<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//过滤出包含某个特定条件的所有元素</div><div class="line">Stream&lt;String&gt; filter = stream.filter(word -&gt; word.length() &gt; 5);</div><div class="line">//对流中值进行某种形式的转化</div><div class="line">Stream&lt;Integer&gt; map = stream.map(String::length);</div><div class="line">//提取子流：裁剪到指定长度</div><div class="line">Stream&lt;String&gt; limit = stream.limit(5);</div><div class="line">//提取子流：跳过前面若干元素</div><div class="line">Stream&lt;String&gt; skip = stream.skip(5);</div><div class="line">//连接两个流</div><div class="line">Stream&lt;String&gt; concat = Stream.concat(Stream.of(&quot;Hello&quot;), Stream.of(&quot;World&quot;));</div><div class="line">//对流中的元素调用某个方法，然后返回同样的流</div><div class="line">Stream&lt;String&gt; peek = stream.peek(System.out::println);</div><div class="line">//对流中元素去重</div><div class="line">Stream&lt;String&gt; distinct = stream.distinct();</div><div class="line">//对流中元素排序</div><div class="line">Stream&lt;String&gt; sorted = stream.sorted(Comparator.reverseOrder());</div></pre></td></tr></table></figure></p>
<p>其中最为关键的2种操作当属<em>filter</em>和<em>map</em>方法。前者传入一个从T到boolean的方法，它会产生一个只包含符合特定条件之元素的新流；后者传入一个从T到R的方法，会在流中的每个元素上执行传入的代码以完成转化；与map方法类似的还有一个<em>flatMap</em>方法，它的背后另有一套复杂理论，不是Stream的专属，但在流中，它的作用是将一个包含多个流的流展开为一个流，即从Stream<stream<t>&gt;到Stream<t>。</t></stream<t></p>
<p>这里对应Stream的第2个特点：Stream操作不会改变原Stream，而是返回一个持有操作结果的新Stream。</p>
<h4 id="Optional操作"><a href="#Optional操作" class="headerlink" title="Optional操作"></a>Optional操作</h4><p>在Stream终止操作之前呢，插一段关于Optional的。</p>
<p>所谓Optional，和它的字面意思一样，是对一个值的封装，既然是“可选的”，那么封装的这个值就有可能不存在，但是Optional不会返回null，因此<em>相对来说</em>更安全。为什么是相对来说呢？因为如果只是用get()和ifPresent()两个方法来取出Optional封装的值，以及判断Optional是否封装了值，未免太生硬了，而且还是避免不了NPE。</p>
<p>首先如何创建Optional呢？使用of()和empty()方法，但这段逻辑Java8已经帮我们封装出了一个ofNullable()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private static Optional&lt;String&gt; getStringOptional(String str) &#123;</div><div class="line">    //如果str为null，返回空的Optional，否则返回封装了str的Optional</div><div class="line">    //完全等价于 return Optional.ofNullable(str);</div><div class="line">    return str == null ? Optional.empty() : Optional.of(str);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其次如何使用Optional呢？使用ifPresent()和orElse(T)/orElseGet|Throw()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//如果Optional中有值，就执行System.out::println</div><div class="line">getStringOptional(null).ifPresent(System.out::println);</div><div class="line">getStringOptional(&quot;ABC&quot;).ifPresent(System.out::println);</div><div class="line">//如果Optional中没有值，就代换成空串/执行某个方法获取值/抛出异常</div><div class="line">getStringOptional(null).orElse(&quot;&quot;);</div><div class="line">getStringOptional(null).orElseGet(() -&gt; String.valueOf(System.currentTimeMillis()));</div><div class="line">getStringOptional(null).orElseThrow(NoSuchElementException::new);</div></pre></td></tr></table></figure></p>
<p>另外Optional也提供了map()和flatMap()方法，用途和Stream中是一样的，我们可以把Optional想象成一个长度非0即1的Stream，这样理解起来就会容易有一些。</p>
<h4 id="Stream的终止操作"><a href="#Stream的终止操作" class="headerlink" title="Stream的终止操作"></a>Stream的终止操作</h4><p>Stream的终止操作相对前面两者要复杂许多，将分成几个部分。这里提前给出流的第3个特点：操作可能会被延迟执行，意思是说前边的中间操作，看上去像是调用了一个或多个方法，但它们并不是立即就被执行的，而是要等到终止操作到来时才会被执行。</p>
<h6 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h6><p>所谓聚合操作，就是以某种形式，将流中的元素组合为一个，使用reduce()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Stream&lt;Integer&gt; stream1 = Stream.iterate(1, val -&gt; val + 1).limit(10);</div><div class="line">//聚合流的第一种形式，等价于sum=1, sum+=2, sum+=3...</div><div class="line">Optional&lt;Integer&gt; sum1 = stream1.reduce(Integer::sum);</div><div class="line">//聚合流的第二种形式，等价于sum=0, sum+=1, sum+=2...</div><div class="line">Integer sum2 = stream1.reduce(0, Integer::sum);</div><div class="line"></div><div class="line">Stream&lt;String&gt; stream2 = Stream.of(&quot;0&quot;, &quot;12&quot;, &quot;345&quot;, &quot;6789&quot;);</div><div class="line">//聚合流的第三种形式</div><div class="line">Integer sum3 = stream2.reduce(0, (sum, word) -&gt; sum += word.length(), Integer::sum);</div></pre></td></tr></table></figure></p>
<p>聚合最简单的实现就是从流的前两个元素开始，或者从一个给定的值和流的第一个元素开始，不断将聚合函数应用到流中的其他元素上。第三种形式相对特殊一些，本例是求String流中各个字符串的总长度，但sum+=word.length()不满足BinaryOperator的定义（一个满足(T, T) -&gt; T的函数）。</p>
<p>Java8另外提供了几个简便，但是常用的reduce操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//返回流中元素个数</div><div class="line">Long count = stream1.count();</div><div class="line">//返回流中元素最小值</div><div class="line">Optional&lt;Integer&gt; min = stream1.min(Integer::compareTo);</div><div class="line">//返回流中元素最大值</div><div class="line">Optional&lt;Integer&gt; max = stream1.max(Integer::compareTo);</div><div class="line">//返回流中满足指定条件的第一个元素</div><div class="line">Optional&lt;Integer&gt; findFirst = stream1.filter(val -&gt; val &gt; 5).findFirst();</div><div class="line">//返回流中满足指定条件的任意一个元素(并行计算)</div><div class="line">Optional&lt;Integer&gt; findAny = stream1.parallel().filter(val -&gt; val &gt; 5).findAny();</div><div class="line">//返回返回流中是否有元素满足指定条件(并行计算)</div><div class="line">Boolean anyMatch = stream1.parallel().anyMatch(val -&gt; val &gt; 5);</div><div class="line">//返回返回流中是否全部元素满足指定条件</div><div class="line">Boolean allMatch = stream1.allMatch(val -&gt; val &gt; 5);</div><div class="line">//返回返回流中是否没有元素满足指定条件</div><div class="line">Boolean noneMatch = stream1.noneMatch(val -&gt; val &gt; 100);</div></pre></td></tr></table></figure></p>
<h6 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h6><p>收集结果一般用在对流进行一番处理之后再来访问流中的元素。除了传统的iterator()方法可以返回这个流的迭代器，以及前文中使用过的toArray()方法将这个流转换成一个数组，Stream提供了collect()方法用于将元素收集起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Stream&lt;Integer&gt; stream = Stream.iterate(1, val -&gt; val + 1).limit(10);</div><div class="line">//收集到ArrayList中</div><div class="line">//完全等价于 stream.collect(Collectors.toCollection(ArrayList::new))</div><div class="line">ArrayList&lt;Integer&gt; arrayList = stream.collect(ArrayList::new, ArrayList::add, ArrayList::addAll);</div><div class="line">//收集到Set和List中(不考虑Collection的具体实现)</div><div class="line">Set&lt;Integer&gt; set = stream.collect(Collectors.toSet());</div><div class="line">List&lt;Integer&gt; list = stream.collect(Collectors.toList());</div><div class="line">//收集成一个String，元素之间以英文逗号分割</div><div class="line">String string = stream.map(String::valueOf).collect(Collectors.joining(&quot;,&quot;));</div><div class="line">//收集成一个特殊的函数，一次性取得count/min/max/avg/sum</div><div class="line">IntSummaryStatistics statistics = stream.collect(Collectors.summarizingInt(Integer::intValue));</div><div class="line">//将表示JVM属性的流收集成一个Map&lt;Object, Object&gt;</div><div class="line">Stream&lt;Map.Entry&lt;Object, Object&gt;&gt; propertyStream = System.getProperties().entrySet().stream();</div><div class="line">Map&lt;Object, Object&gt; propertyMap = propertyStream.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (existKey, newKey) -&gt; newKey));</div></pre></td></tr></table></figure></p>
<p>对于收集成Map的情况，toMap()方法需要3个参数，第1个是Map的Key，第2个是Map的Value，这两个比较基础，但第3个是一个函数，用于处置Key重复的情形，例子中直接舍弃了旧的留下新的，如果需要两者均保留，那么一是收集结果将变成类似Map<object, set<object="">&gt;，二是上面第3个参数的逻辑将变成重新实例化一个Set将新旧Set中的值全部添加进去。</object,></p>
<h6 id="分组和分片"><a href="#分组和分片" class="headerlink" title="分组和分片"></a>分组和分片</h6><p>上一节中我们收集Map的行为，实际上就是这里的分组，我们大可比不那般简单粗暴，完全可以使用groupingBy()方法代替<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Stream&lt;Map.Entry&lt;Object, Object&gt;&gt; propertyStream = System.getProperties().entrySet().stream();</div><div class="line">//按Key分组</div><div class="line">Map&lt;Object, List&lt;Map.Entry&gt;&gt; propertyMap = propertyStream.collect(Collectors.groupingBy(Map.Entry::getKey));</div><div class="line">//按Value是否为空分组</div><div class="line">Map&lt;Boolean, List&lt;Map.Entry&gt;&gt; propertyIsBlankMap = propertyStream.collect(Collectors.groupingBy(entry -&gt; entry.getValue().toString().equals(&quot;&quot;)));</div></pre></td></tr></table></figure></p>
<p>groupingBy()方法的参数是分类的依据，一般地，指定Key，如果指定了一个返回布尔值的函数，那么整个流将按照这个布尔值的真假分成2类。</p>
<p>而分类后的Map的Value部分，一般地，为原始流中的某个元素，如果我们要对它进行加工处理，需要指定一个叫做downstream的东西，也即groupingBy()方法的第2个参数，但实际上，在使用之前应当考虑是都真的有必要使用非常非常复杂的聚合表达式，这里只举最简单的例子（可能不是十分恰当）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//按每个属性名对应的属性值个数分组(本例中都是1:1)</div><div class="line">Map&lt;Object, Long&gt; propertyCountMap = propertyStream.collect(Collectors.groupingBy(Map.Entry::getKey,Collectors.counting()));</div><div class="line">//按每个属性名对应的属性值的长度的数学特征分组</div><div class="line">Map propertyLengthMap = propertyStream.collect(Collectors.groupingBy(Map.Entry::getKey,Collectors.summarizingInt(entry -&gt; entry.getValue().toString().length())));</div></pre></td></tr></table></figure></p>
<h4 id="原始类型流"><a href="#原始类型流" class="headerlink" title="原始类型流"></a>原始类型流</h4><p>之前我们需要包含原始数据类型的流时，用的都是他们的包装类型，诸如Stream<integer>，Stream<double>等，尽管有对基本数据类型的自动装箱拆箱机制，但多少对性能有一定影响。Java8同期提供了3种基本数据类型——int、long、double对应的Stream，分别是IntStream、LongStream、DoubleStream，但不提供byte、short、char、boolean、float类型的原始类型流。</double></integer></p>
<p>原始类型流的创建，以及其方法的调用和对象流有几分相似，另外还支持很对象流的相互转换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//直接创建int、long、double三种原始类型流</div><div class="line">IntStream stream1 = Arrays.stream(new int[]&#123;1, 2, 3, 4, 5, 5, 6, 7, 8, 9&#125;);</div><div class="line">LongStream stream2 = LongStream.rangeClosed(1, 100);</div><div class="line">DoubleStream stream3 = new Random().doubles();</div><div class="line">//从对象流转换</div><div class="line">Stream&lt;String&gt; stream4 = Stream.of(&quot;0&quot;, &quot;12&quot;, &quot;345&quot;, &quot;6789&quot;);</div><div class="line">IntStream stream5 = stream4.mapToInt(String::length);</div><div class="line">//包装回对象流</div><div class="line">Stream&lt;Integer&gt; stream6 = stream1.boxed();</div></pre></td></tr></table></figure></p>
<h4 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h4><p>其实早在前面就提到过了并行操作，缺省的，当使用stream()方法获得一个流时，它是串行的，要得到并行流，应当使用parallelStream()方法，或者在串行流上调用parallel()方法。既然是并行，就不得不考虑并发错误，这里需要注意的点和从前是一样的。另外在并行条件下不得不提的是有序问题，一般地，并发执行意味着结果的不确定性，但Stream对此提供了一定的保证，如果我们没有保持有序的需求，可以调用unordered()让后续的操作更高效地并行。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[（备忘）Android应用中图片类资源分辨率参考]]></title>
      <url>http://www.lx1992.com.cn/2017/02/04/android-mipmap-resolution/</url>
      <content type="html"><![CDATA[<p>偶尔也会做点Android的应用，每每用到图片素材，在寻找和加工过程中，多少会疑惑什么分辨率合适。这次刚好参考了一些别人的做法，加上自己找了几种不同分辨率的手机测试了下效果说得过去，记下来做个备忘。</p>
<a id="more"></a>
<p>首先现在用AS建好工程以后图片类素材分了5种DPI：mdpi、hdpi、xhdpi、xxhdpi、xxxhdpi，每种DPI下都预置了Android的小机器人作为应用的启动器图标，它的分辨率就可以做为一个参考</p>
<table>
<thead>
<tr>
<th>DPI</th>
<th>分辨率</th>
</tr>
</thead>
<tbody>
<tr>
<td>mdpi</td>
<td>48</td>
</tr>
<tr>
<td>hdpi</td>
<td>72</td>
</tr>
<tr>
<td>xhdpi</td>
<td>96</td>
</tr>
<tr>
<td>xxhdpi</td>
<td>144</td>
</tr>
<tr>
<td>xxxhdpi</td>
<td>192</td>
</tr>
</tbody>
</table>
<p>有些情况下可能还是觉得这个分辨率大了，所以另外找了Google官方的<a href="https://design.google.com/icons/" target="_blank" rel="external">Material Design Icons</a>，它里面提供的大多是这个分辨率</p>
<table>
<thead>
<tr>
<th>DPI</th>
<th>分辨率</th>
</tr>
</thead>
<tbody>
<tr>
<td>mdpi</td>
<td>24</td>
</tr>
<tr>
<td>hdpi</td>
<td>36</td>
</tr>
<tr>
<td>xhdpi</td>
<td>48</td>
</tr>
<tr>
<td>xxhdpi</td>
<td>72</td>
</tr>
<tr>
<td>xxxhdpi</td>
<td>96</td>
</tr>
</tbody>
</table>
<p>做Icon非常适合。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java8学习之默认方法]]></title>
      <url>http://www.lx1992.com.cn/2017/01/30/java8-default-methods/</url>
      <content type="html"><![CDATA[<p>这部分是关于的Java8在接口中定义默认方法和静态方法的。实话说，我一时没看出来这个和Lambda表达式有什么关系，也不知道为什么书上会安排在同一章，我还是拆来来吧。</p>
<a id="more"></a>
<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>同样在Java8以前，接口当中是不会存在任何方法实现的，在某种程度上可以看做纯抽象的的方法。</p>
<p>这就有一个问题，想象有一个接口I，经过若干次迭代，它已经有了A、B、C、D……N个实现类，突然有一天，接口I中不得不新增一个方法，然后它的N个实现类要一一实现这个新的方法吗？可不可以让接口中这个新的方法提供一个默认实现呢？</p>
<p>恐怕我们很容易联想到早些年AWT中的事件模型，例如窗口事件java.awt.event.WindowListener，它有7个方法未实现，而很可能我们只需要点击关闭窗口时弹出一个确认对话框一个功能……于是就有了java.awt.event.WindowAdapter这么个东西，把每个方法都做了一个空的实现。这样做当然不是不可以，但利用Java8的默认方法要简单不少，用default关键字声明默认方法即可，至少不用定义Adapter类了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Lived &#123;</div><div class="line">    default String getDescription() &#123;</div><div class="line">        return &quot;有生命的&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不过新的问题又出现了，Java是允许接口多继承的，万一接口A、B都对某个共享方法X提供了默认实现，偏偏接口C又同时继承了接口A、B怎么办？是不是突然有种当年学C++时解决菱形继承的既视感？莫方，Java8对这种问题的解决办法简单粗暴——开发人员自己决定！也就是说，你必须写代码来决定，究竟是自己再重写一次方法X，还是从A、B的实现中选一个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public interface Named &#123;</div><div class="line">    default String getDescription() &#123;</div><div class="line">        return &quot;有名字的&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Human implements Lived, Named &#123;</div><div class="line">    //必须重写冲突的getDescription方法</div><div class="line">    @Override</div><div class="line">    public String getDescription() &#123;</div><div class="line">        return &quot;人类&quot;;</div><div class="line">        //或可以指定某个父接口的默认实现</div><div class="line">        //return Lived.super.getDescription();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再换一种情况，假设类C继承了类B又实现了接口A，偏偏接口A对方法X提供了默认实现，类B覆盖了这个实现，在C不重写方法X的情况下，生效的将会是类B中的实现，接口A中的默认实现会被忽略，这称为“类优先”原则。</p>
<p>这就有问题了，而且我个人感觉不是很容易被察觉到：接口也是一种特殊的类，它也是继承Object类的，根据类优先原则，我们就永远不可能为Object类中的方法定义默认实现。</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>不知道你有没有被诸如Collection/Collections这样长得贼像的“兄弟”坑过呢？反正我是有，有时候着急了，或者敲快了，还对着错误一头雾水的。其实，这两家伙，前者是接口，后者是类，而且后者为前者提供一些工具方法或者工厂方法。</p>
<p>Java8开始，不仅允许在接口中添加默认方法，还允许添加静态方法了！不知道可不可以认为像Collections这样的类没有太大用处了呢？</p>
<p>允许这么做是有原因的。即使是默认方法，也需要通过Lambda表达式实例化函数式接口，或者某个实现了这个接口的类的实例才可以访问到，这让静态工厂方法们情何以堪啊？当然下面这个例子有点随意了=.=<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Lived &#123;</div><div class="line">    static boolean instanceOf(Object obj) &#123;</div><div class="line">        return obj instanceof Lived;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java8学习之Lambda表达式]]></title>
      <url>http://www.lx1992.com.cn/2017/01/29/java8-lambda-expressions/</url>
      <content type="html"><![CDATA[<p>Java8，准确地说应该是JavaSE 8，发布挺长时间了（废话！Java9今年上半年都要出了！），但除了实习那会听同事做了场分享，自己一直没有系统地学习一下。这些天整了本《写给大忙人看的JavaSE 8》，抽点时间读一读，这个系列的博客当是读书笔记了。这第一部分是lambda表达式。</p>
<a id="more"></a>
<h4 id="何为lambda表达式"><a href="#何为lambda表达式" class="headerlink" title="何为lambda表达式"></a>何为lambda表达式</h4><p><em>lambda表达式是一段可以传递的代码。</em></p>
<p>过去在多线程、回调等情境（大多是内部类？）下，我们都会把一段代码传递给其他调用者，而这段代码稍后才会被调用。而纯面向对象的Java是不支持传递代码块的，但在Java8中，可以。</p>
<p>第一个lambda表达式，包括两部分——一是代码块本身，二是传递给代码块的参数，注意lambda的返回类型永远是推导来的，不需要显式指定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 格式：参数+箭头+表达式</div><div class="line">(int a, int b) -&gt; foo.bar(a, b);</div></pre></td></tr></table></figure></p>
<p>但lambda的格式也不是说就这么死板，有几种特殊情况：如果代码块不是一个表达式（多行代码、处理异常等），那么就用大括号包裹起来；如果没有参数，那么将小括号置空；如果参数的类型是可以推导的，那么参数类型可以省略；如果有且只有一个可以被推导的参数，那么甚至可以省略小括号。</p>
<h4 id="lambda表达式能做什么"><a href="#lambda表达式能做什么" class="headerlink" title="lambda表达式能做什么"></a>lambda表达式能做什么</h4><p><em>lambda表达式有且只能用于函数式接口转换</em></p>
<p>对只包含一个抽象方法的接口，我们可以用lambda表达式来创建该接口的实例，这种接口也被称作函数是接口。而所谓“一个抽象方法”，则是因为Java8允许在接口中定义非抽象方法。</p>
<p>以java.util.Comparator接口为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Comparator&lt;T&gt; &#123;</div><div class="line">    //抽象方法</div><div class="line">    int compare(T var1, T var2);</div><div class="line"></div><div class="line">    //Object类中有实现，不是抽象方法</div><div class="line">    boolean equals(Object var1);</div><div class="line"></div><div class="line">    //有默认实现，不是抽象方法</div><div class="line">    default Comparator&lt;T&gt; reversed() &#123;</div><div class="line">        return Collections.reverseOrder(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //以下省略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>符合上面对函数式接口的定义，因此Comparator是函数式接口，可以通过lambda表达式实例化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Comparator comparator = (a, b) -&gt; foo.bar(a, b);</div></pre></td></tr></table></figure></p>
<p>至于注解@FunctionalInterface，意识可以让编译器帮着检查这个接口符不符合函数式接口的定义，二是生成JavaDoc时对这个接口有一个标记，因此推荐使用。</p>
<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>对于类似这样的lambda表达式，我们有更方便的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//下面两者是等价的</div><div class="line">(x) -&gt; foo.bar(x)</div><div class="line">foo::bar</div></pre></td></tr></table></figure></p>
<p>实际上就是将foo这个对象中的boo方法，整个传递给某个函数式接口。方法引用又分成三类</p>
<ul>
<li>对象::实例方法</li>
<li>类::静态方法</li>
<li>类::实例方法</li>
</ul>
<p>前两个没有什么特殊之处，注意对象可以是自己或者自己的父类（即this或super），但最后一个，类如何调用实例方法呢？实践后会发现，这种情况下总要求函数式接口中那个抽象方法的参数要比引用的方法的参数多一个，而且这多出来的参数就是类的实例。</p>
<p>更进一步地，我们还可以引用类的构造方法，不过方法名不是我们在反射时见到的<init>，就是简单明了的new了～再特殊一点，如果引用的是数组的构造方法，则需要隐含这一个参数，即数组长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//引用类的实例方法，下面两者也是等价的</div><div class="line">String::equals</div><div class="line">(x, y) -&gt; x.equals(y)</div><div class="line"></div><div class="line">//引用构造方法</div><div class="line">String::new</div><div class="line">int[]::new</div></pre></td></tr></table></figure></init></p>
<h4 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h4><p>在Java8以前，这样的代码会产生编译错误：要求将count声明为final类型，因为我们在一个内部类中引用了外部类的局部变量count，很可能当内部类要用到count时，外部类已经不存在了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void runnableWithoutLambda(int count) &#123;</div><div class="line">    Runnable runnable = new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">                System.out.println(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    new Thread(runnable).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但到了Java8，这样做却被“允许”了，当然不可能是无条件的放开，只是不一定要显式地声明final——“等效于final”即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void runnableWithLambda(int count) &#123;</div><div class="line">    Runnable runnable = () -&gt; &#123;</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            System.out.println(i);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    new Thread(runnable).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>事实上，像count这样既不是lambda表达式的参数，也不是定义在lambda表达式的代码块中的变量，被称为“自有变量”，而这个特性被称为“捕获”，含有自有变量的代码块被称为“闭包”。为了实现这个特性，lambda表达式会存储这些变量，既然这些变量等效于final，它们就不允许被修改，即使编译器不报错，尤其在多线程条件下，结果是完全不可预估的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[搭建Redmine「项目管理」服务]]></title>
      <url>http://www.lx1992.com.cn/2017/01/17/install-redmine-server/</url>
      <content type="html"><![CDATA[<p>Redmine是一款以Ruby on Rails撰写的项目管理和缺陷跟踪工具，和国产的禅道可能有几分类似，但和业内顶尖的Jira应该还是有一定差距的吧？但毕竟人家是开源免费的，相应的功能，诸如项目排期，Bug跟踪，Wiki什么的，对我们这种小团队而言基本也够用了。</p>
<a id="more"></a>
<p>现在我们来部署Redmine。先扯一句，网上挺多建议用Bitnami来部署的，的确也是，按照官方的教程来步骤真的挺复杂的，不过既然已入坑，就不半途而废了。首先当然是要下载好Redmine，才2M多，厉害啊，下载完后照例解压缩到/opt目录，另外，安装过程中要下载不少依赖，确保你的服务器能访问外网哈～</p>
<h4 id="检查Ruby和Rails环境"><a href="#检查Ruby和Rails环境" class="headerlink" title="检查Ruby和Rails环境"></a>检查Ruby和Rails环境</h4><p>我们即将部署的是最新的Redmine 3.3，这个版本要求Ruby 1.9.3+、Rails 4.2。绝大部分Linux发行版都是预装了Ruby的，可用这两个命令检查服务器上的Ruby和Rails版本，在我们的环境中，两者的版本分别是2.3.1和4.2.7.1，符合Redmine要求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 查看Ruby版本</div><div class="line">ruby -v</div><div class="line"># 查看Rails版本</div><div class="line">rails -v</div></pre></td></tr></table></figure></p>
<h4 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h4><p>Redmine同样提供了对多种数据库的支持，我们还是选用MySQL。</p>
<p>MySQL侧，自然还是建立一个名为redmine的数据库和用户并授权了，这一步已经重复太多次了。</p>
<p>Redmine侧呢，将./config目录下的database.yml.example文件重命名为database.yml，打开它可以看到这个文件是按着环境分级的，目前我们只需要production环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">production:</div><div class="line">  adapter: mysql2</div><div class="line">  database: redmine</div><div class="line">  host: 127.0.0.1</div><div class="line">  port: 3306</div><div class="line">  username: redmine</div><div class="line">  password: &quot;password&quot;</div><div class="line">  encoding: utf8</div></pre></td></tr></table></figure></p>
<p>注意adapter字段是mysql2而不是mysql，据说前者性能高于后者，相关的依赖下一步中我们会安装；port字段默认是没有的，但当你改变了数据库服务器默认的3306端口时就需要加上了；password字段本身的引号最好不要误删。</p>
<h4 id="关于gem"><a href="#关于gem" class="headerlink" title="关于gem"></a>关于gem</h4><p>这一段其实是写到后面又回过头来补充的。</p>
<p>后文中会多次出现一个叫做gem的东西。gem是以标准格式封装好的ruby程序或库，可以和java的jar做类比；但如果是在命令行中执行gem，其实是调用ruby的包管理器rubygem来管理gem包的行为，可以和nodejs的npm做类比。</p>
<p>在国内，由于某些原因，下载gem包的速度就两个字：呵呵，除了FQ，或者不停地retry，更直接的方法应当是更换国内的gem源。网上大部分资料都建议用淘宝源，但淘宝已经停止对这个源的维护了，后续的维护交由ruby-china进行，所以我们应该更换成ruby-china的源。对gem源的操作使用gem sources命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 添加ruby-china源</div><div class="line">gem sources -a https://gems.ruby-china.org/</div><div class="line"># 移除官方源</div><div class="line">gem sources -r https://rubygems.org/</div><div class="line"># 列出当前使用的源</div><div class="line">gem sources -l</div><div class="line"># 更新源的缓存</div><div class="line">gem sources -u</div></pre></td></tr></table></figure></p>
<h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>Redmine的基本安装过程需要不少依赖，某些依赖又有别的依赖[汗……]，但总的来看，初期安装还不算多，就3个，mysql2、rmagick和rbpdf-font。</p>
<p>首先安装mysql2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">adb install libmysqlclient-dev</div><div class="line">gem insatll mysql2</div></pre></td></tr></table></figure></p>
<p>一开始我直接执行了第2步，好在mysql2也是蛮贴心的，提示我需要先执行第1步[赞]，安装前置依赖libmysqlclient-dev。</p>
<p>然后是安装RMagick，因为redmine处理一些图片时用到了一个叫做ImageMagick的库，而RMagick作为Ruby和ImageMagick的中间接口，自然也是必不可少的。</p>
<p>但这个的安装就没有mysql2那么幸运了，报错就提示我“可能缺少某些依赖”，可到底缺了啥，谁也不知道，幸好<a href="https://github.com/rmagick/rmagick#install" target="_blank" rel="external">官方文档</a>中说了它还依赖于libmagickwand-dev（咳咳，这个依赖又依赖好多组件哇……）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt install libmagickwand-dev</div><div class="line">gem install rmagick</div></pre></td></tr></table></figure></p>
<p>最后剩下rbpdf-font了，这个倒没影响我的安装，给我整了个在配置的时候报错[无语]，看在它没啥太复杂依赖的份上，原谅它吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem install rbpdf-font</div></pre></td></tr></table></figure></p>
<h4 id="安装redmine"><a href="#安装redmine" class="headerlink" title="安装redmine"></a>安装redmine</h4><p>redmine使用gem bundler来管理自身的gem依赖，所以首先要安装bundler，然后方可使用bundler安装redmine所需的其他依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gem install bundler</div><div class="line">bundle install --without development test</div></pre></td></tr></table></figure></p>
<p>注意哦，执行第2步的时候会去读取redmine目录下的Gemfile文件，所以要在redmine目录下执行～然后就静静看着bundler刷刷刷又下载了一堆依赖好了……</p>
<h4 id="安装后的几个步骤"><a href="#安装后的几个步骤" class="headerlink" title="安装后的几个步骤"></a>安装后的几个步骤</h4><p>我直接罗列出来了，每一步是干什么的也都给了注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 生成一个随机密钥供session存储使用</div><div class="line">bundle exec rake generate_secret_token</div><div class="line"># 创建数据库表结构</div><div class="line">RAILS_ENV=production bundle exec rake db:migrate</div><div class="line"># 加载初始数据</div><div class="line">RAILS_ENV=production REDMINE_LANG=zh bundle exec rake redmine:load_default_data</div></pre></td></tr></table></figure></p>
<p>这里我报了2个错</p>
<blockquote>
<p>warning: duplicated key at line 466 ignored: “inodot”<br>LoadError: cannot load such file – rbpdf-font</p>
</blockquote>
<p>第1个错误解决的办法是打开报错的这个文件（expanded.rb），按照提示，465行和466行重复了，不知道是个bug还是咋回事，注释掉其中一行就好了；</p>
<p>而第2个错一开始我还挺纠结了，也才有了安装依赖那一小节里边安装rbpdf-font的过程。其实，对于这种扩展依赖，还应该新建一个Gemfile.local文件，在里边加上对rbpdf-font的依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 添加到Gemfile.local中</div><div class="line">gem “rbpdf-font”, “~&gt;1.19.0”</div></pre></td></tr></table></figure></p>
<h4 id="其他几个配置"><a href="#其他几个配置" class="headerlink" title="其他几个配置"></a>其他几个配置</h4><p>至此redmine基本上已经安装完成了，确实也没那么简单，但还有几个可选的配置可以看一下。打开./config/configuration.yml（由configuration.yml.example重命名而来，和database.yml一样），里面有3个配置</p>
<ul>
<li>邮件通知</li>
<li>版本控制</li>
<li>附件目录</li>
</ul>
<p>其中，邮件通知，根据smtp服务不同，配置文件中已经提供了数种示例，肯定有适合的一种；版本控制，主要是配置同redmine整合的版本控制程序的路径等，默认自动检测一般不会有什么问题；附件目录相对比较重要，因为用户上传的东西什么的都在这里，应当要移动到安全性高一点、空间大一点的目录。</p>
<p>在configuration.yml中没有关于日志的配置，查阅<a href="http://www.redmine.org/projects/redmine/wiki/RedmineInstall" target="_blank" rel="external">官方文档</a>可知，这个配置是可选的，应当配置在additional_environment.rb中，格式形如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 构造Logger的3个参数分别是日志文件名、最多保留文件个数、单个文件最大大小(字节)</div><div class="line">config.logger = Logger.new(&apos;/path/to/logfile.log&apos;, 2, 1000000)</div><div class="line">config.logger.level = Logger::INFO</div></pre></td></tr></table></figure></p>
<p>最后还有一个名为setting.yml的配置文件，我们无需直接修改它，其中的配置项都可以在redmine运行起来以后，以管理员身份登录去修改。</p>
<h4 id="运行redmine"><a href="#运行redmine" class="headerlink" title="运行redmine"></a>运行redmine</h4><p>万事俱备只欠东风<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bundle exec rails server webrick -e production -b 0.0.0.0 -p 8080</div></pre></td></tr></table></figure></p>
<p>这个命令是用webrick作为http服务器来运行redmine，-e参数指定环境（我们也只有production环境），-b参数指定绑定的ip地址，-p参数指定绑定的端口号。redmine启动后即可通过浏览器访问，初始的用户名密码都是admin。</p>
<p>但是！webrick只适合测试环境使用，据说它有性能问题，网上更多的建议使用thin、puma、mongrel等代替。本着哪个简单用哪个，试试thin吧。</p>
<p>首先自然是安装thin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem install thin</div></pre></td></tr></table></figure></p>
<p>和rbpdf-font相似，在Gemfile.local中再加入一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem &apos;thin&apos;</div></pre></td></tr></table></figure></p>
<p>然后重新运行就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bundle install --without development test</div></pre></td></tr></table></figure></p>
<p>使用thin作为http服务器后，redmine的启动方式有所改变，-e和-p的含义没变，-a指定绑定的且默认就是0.0.0.0，-d在后台运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thin start -e production -a 0.0.0.0 -p 3000 -d</div></pre></td></tr></table></figure></p>
<p>一般地，还需要将redmine配置成service<!--，方法看[这里]()-->。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[搭建SonarQube「代码质量管理」服务]]></title>
      <url>http://www.lx1992.com.cn/2017/01/17/install-sonarqube-server/</url>
      <content type="html"><![CDATA[<p>sonarqube是一个代码质量管理工具，同样是<a href="https://github.com/SonarSource/sonarqube" target="_blank" rel="external">开源</a>的，说白了其实它做的事也是“代码静态分析”，和安装在IDE中的findbugs、checkstyle等插件有几分类似。官方称其支持20+种语言，对java的支持更是不在话下。</p>
<a id="more"></a>
<p>我也是在实习期间第一次接触到这个工具，公司里将它同jenkins这一持续集成工具整合，从而实现每每向git仓库提交代码就自动触发编码质量检查的目的。检查的结果呢，根据问题的类型和严重性，在其web界面上一目了然，老大快瞅瞅哪个程序猿儿欠下了哪些技术债[坏笑]。如果进一步和CI整合，还可以限制诸如代码质量达不到某个级别就不允许进一步操作等，从而确实提高编码质量。</p>
<p>现在我也在自己的云主机上搭建一套sonarqube环境。首先要明确一点，sonarqube从整体上看分成两部分，server和scanner。其中在服务器上安装的为server部分，且server需要连接数据库来存储自身的配置和检查结果等、需要安装插件来实现对不同语言、不同VCS的支持等。至于scanner，那是运行在CI、IDE或者maven等项目管理工具上的，作用就是分析项目。</p>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>sonarqube在其<a href="https://www.sonarqube.org/downloads/" target="_blank" rel="external">官方网站</a>上就可以完整下载到，体积看上去不小，再看看最低硬件要求，实话说也蛮高的，我猜测可能和它包含了web服务、cs计算引擎、es全文索引三大件有关吧，下载完毕后解压到/opt目录即可。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>sonarqube的配置文件位于./conf目录下，包括sonar.properties<br>和wrapper.conf两个，依次打开看看。</p>
<h5 id="sonar-properties"><a href="#sonar-properties" class="headerlink" title="sonar.properties"></a>sonar.properties</h5><p>这个文件是sonarqube的核心配置文件了，可以/需要配置的东西还是不少的。粗略浏览一下，包括这么几个部分</p>
<ul>
<li>数据库</li>
<li>Web服务器</li>
<li>SSO鉴权</li>
<li>计算引擎</li>
<li>全文搜索引擎</li>
<li>代理服务器</li>
<li>日志</li>
<li>其他杂项 &amp; 开发者选项</li>
</ul>
<p>受限于篇幅，本文参考官方教程，简单阐述一些必须的配置。首先自然是数据库老三样——URL、用户名和密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sonar.jdbc.username=sonarqube</div><div class="line">sonar.jdbc.password=password</div><div class="line">sonar.jdbc.url=jdbc:mysql://localhost:3306/sonarqube</div></pre></td></tr></table></figure></p>
<p>其次是HTTP服务绑定的网卡和端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sonar.web.host=0.0.0.0</div><div class="line">sonar.web.port=9000</div></pre></td></tr></table></figure></p>
<p>最后是官方建议的，对Web服务所在的jvm启用-server参数，据说可以提高性能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sonar.web.javaOpts=-server</div></pre></td></tr></table></figure></p>
<p>哦对了，数据目录和日志目录不必多说，看过我前面几篇博客都应该发现我将所有与业务的这两个目录统一放在/data下了。</p>
<p>至于其他的配置项，由于配置文件里的说明十分详细，有需要的同学可以按着说明调整相关的配置。</p>
<h5 id="wrapper-conf"><a href="#wrapper-conf" class="headerlink" title="wrapper.conf"></a>wrapper.conf</h5><p>这个文件配置的是Java Service Wrapper，它是啥大伙自行谷歌去。</p>
<p>虽然这个文件标明了，除了JVM路径以外的内容不要修改，但毕竟其中包含了wrapper的日志目录，而且默认的配置是大小不限制、文件数不限制，如果访问量大的话，不可避免地会在程序目录下打出太多的日志，所以还是把这个改一下吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wrapper.logfile=/data/logs/sonarqube/sonar.log</div><div class="line"></div><div class="line"># 下面2行默认是注释掉的，相应的特性也被禁用了，根据需要修改</div><div class="line">wrapper.logfile.maxsize=0</div><div class="line">wrapper.logfile.maxfiles=0</div></pre></td></tr></table></figure></p>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>进入./bin目录，可以看到sonarqube支持的各种操作系统中所对应的不同启动程序，以我们的linux-x86_64为例，运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./sonar.sh start</div></pre></td></tr></table></figure></p>
<p>即可启动sonarqube。通过浏览器访问server的url就可以看到sonarqube的主界面了（当然第一次访问还需要进行一些初始化工作）。</p>
<p>官方的教程中还提到了<a href="https://docs.sonarqube.org/display/SONAR/Running+SonarQube+as+a+Service+on+Linux" target="_blank" rel="external">如何将sonarqube配置成系统服务</a>，</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>注意了，刚才安装和启动的那只是server部分，前面说过，server一般用来查看分析的结果并做相应的处理，我们还需要scanner来进行代码的分析。<a href="https://docs.sonarqube.org/display/SONAR/Analyzing+Source+Code" target="_blank" rel="external">官方教程</a>中明确了scanner的6种使用方式。因为我们项目是用maven管理的，又暂时没有接入jenkins，所以这里我们直接通过sonarqube的maven插件进行编码质量检查，顺便做个示范。</p>
<p>首先要在项目的pom文件中加上sonarqube的maven插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;</div><div class="line">  &lt;groupId&gt;org.sonarsource.scanner.maven&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;sonar-maven-plugin&lt;/artifactId&gt;</div><div class="line">  &lt;version&gt;3.2&lt;/version&gt;</div><div class="line">&lt;/plugin&gt;</div></pre></td></tr></table></figure></p>
<p>这个插件只需要配置一个属性，那就是我们前边部署的server的url<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;properties&gt;</div><div class="line">  &lt;sonar.host.url&gt;</div><div class="line">    http://host:port</div><div class="line">  &lt;/sonar.host.url&gt;</div><div class="line">&lt;/properties&gt;</div></pre></td></tr></table></figure></p>
<p>然后就可以进行编码质量检查了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn clean verify sonar:sonar</div></pre></td></tr></table></figure></p>
<p>用不了多长时间结果就会被上传，此时用浏览器打开sonarqube的server端，就可以看到代码分析的结果了，各种不规范、坏味道一目了然。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[搭建Redis服务器]]></title>
      <url>http://www.lx1992.com.cn/2017/01/15/install-redis-server/</url>
      <content type="html"><![CDATA[<p>Redis，一个开源、支持多种数据结构，亦支持集群和副本且高性能的内存存储。尽管它可被视为内存数据库，但更多地，我们在程序中把它当成缓存使用。缓存的内容也是多种多样，举几个简单的例子，常备访问的数据、维持会话的token，验证码等时效性较强的数据……</p>
<a id="more"></a>
<p>在搭建redis服务器，官方给出的教程是通过源码自行编译和安装。说是说make是个神器，但在ubuntu中，系统的软件源早已为我们准备好了一切，let’s go!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt install redis-server</div></pre></td></tr></table></figure></p>
<p>一步搞定有木有？嗯，想要挑战一下官方教程的当然也可以，看<a href="https://github.com/antirez/redis" target="_blank" rel="external">这里</a>和<a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-redis-on-ubuntu-16-04" target="_blank" rel="external">这里</a>。我自己其实也试验过，没有想象的那么复杂，无非gcc和make报几个错，缺少依赖的头文件什么的，解决起来也挺简单。</p>
<p>前面的一键安装事实上同时安装好了server和client，在终端中运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-cli</div></pre></td></tr></table></figure></p>
<p>就会自动连接localhost:6379上的redis-server，试着执行几个命令(“127.0.0.1:6379&gt;”打头的行是我们的输入，顶格的行是redis的输出)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; ping</div><div class="line">PONG</div><div class="line"></div><div class="line">127.0.0.1:6379&gt; set hello &quot;world&quot;</div><div class="line">OK</div><div class="line"></div><div class="line">127.0.0.1:6379&gt; get hello</div><div class="line">&quot;world&quot;</div></pre></td></tr></table></figure></p>
<p>这样一来redis其实已经可用了，但还不够，至少我们要修改一下端口号、绑定的网卡、数据和日志文件路径什么的，vim打开/etc/redis/redis.conf，找到下面几行，大概位于50~200行之间，做相应的修改即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">port 6379</div><div class="line">bind 127.0.0.1</div><div class="line">logfile /var/log/redis-server.log</div><div class="line">dir /var/lib/redis</div></pre></td></tr></table></figure></p>
<p>修改完问题就来了，redis服务停止以后再也启动不了了，因为是systemd启动服务时出错，所以日志打到了/var/log/syslog里边，一开始找了有些时候，看错误日志，说的是</p>
<blockquote>
<p>Jan 14 06:08:56 pocket-erp-db redis-server[3118]: Reading the configuration file, at line 108<br>Jan 14 06:08:56 pocket-erp-db redis-server[3118]: &gt;&gt;&gt; ‘logfile /data/logs/redis/redis-server.log’<br>Jan 14 06:08:56 pocket-erp-db redis-server[3118]: Can’t open the log file: Read-only file system</p>
</blockquote>
<p>神马？？说日志所在的/data挂载点是只读的？因为/data挂载的是一块云硬盘，实习那会在公司的测试机上也碰到过类似奇怪的问题。但这回先是mount看了一眼，显示是rw的，试着往里写个文件，也没啥异常，这就奇了怪了。</p>
<p>谷歌走起，先是找到了<a href="http://stackoverflow.com/questions/19238701/redis-wont-start-after-upgrade" target="_blank" rel="external">这个</a>，他说是升级以后引入的BUG，重启一下就没事了，但我试了并不管用，后来找到了<a href="http://unix.stackexchange.com/questions/310219/process-mount-is-read-only/310360" target="_blank" rel="external">这个</a>，才是问题根本的原因。</p>
<p>原来redis认定的“Read-only file system”跟mount显示的结果并不是一回事，他有他自己的一套逻辑，这个逻辑实质上位于systemd的配置中，vim打开/etc/systemd/system/redis.service，会看到下面几行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReadOnlyDirectories=/</div><div class="line">ReadWriteDirectories=-/var/lib/redis</div><div class="line">ReadWriteDirectories=-/var/log/redis</div><div class="line">ReadWriteDirectories=-/var/run/redis</div></pre></td></tr></table></figure></p>
<p>原来除了指定的这3个目录，其他目录对于redis来说都是只读的，难怪会报错呢，改就一个字！别忘了改完这个文件要<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl daemon-reload</div></pre></td></tr></table></figure></p>
<p>重新加载下systemd。</p>
<p>等下！打住！做这几步操作之前麻烦先把服务停下来，虽然我也不确定是不是就是这个原因，我在服务运行期间做了上面的几个操作，再回过头来想重启服务时，卡在了停止服务那一步，更可怕的是，redis设置了“永不超时”……最后费尽周折好不容易重启了服务，幸好没出啥大篓子。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[搭建Disconf「分布式配置管理」服务]]></title>
      <url>http://www.lx1992.com.cn/2017/01/14/install-disconf-server/</url>
      <content type="html"><![CDATA[<p>disconf是百度开源的一套分布式配置管理平台，详情可以戳<a href="https://github.com/knightliao/disconf" target="_blank" rel="external">这里</a>。</p>
<p>尽管类似的平台不在少数，国内的奇虎、阿里等也均有类似开源实现，但它对于我们后端应用中诸多配置，在使用和管理上之方便，是直到博主进入在某大型O2O公司实习时才深有体会。</p>
<a id="more"></a>
<p>试想一下，一个应用，首先肯定有多个环境，至少，线上线下连接的数据库肯定不相同，然后，不论是出于负载均衡，还是可用性方面的考虑，线上业务很可能不是单点的，也就是部署在了多台vm，或者docker中，某天因业务需要，要修改一个配置项……</p>
<p>先解决前一个问题，纵然通过spring或者maven的profile都可以规避这个问题，更简单一点，写一个脚本，在启动程序时带几个跟当前环境相关的jvm启动参数，欧了；后一个问题，更简单了，配置文件一般不都在resource目录下嘛，改之、打包、部署～可……这样真的好么？</p>
<p>本文将通过部署disconf来更高效地解决上面的问题。Come on！补充一句，disconf分为disconf-client和disconf-web两部分，client用在我们的业务系统中，web部署在我们的服务器上，本文两部分都会涉及。</p>
<p>相比于其他应用，disconf的部署主要是依赖的的东西不少，而且都是比较重的，什么mysql、redis、zookeeper，好在这一些我们的其他业务系统也要用到，有些呢，甚至早就部署过了。</p>
<h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><h5 id="mysql和redis"><a href="#mysql和redis" class="headerlink" title="mysql和redis"></a>mysql和redis</h5><p>作为最常见的关系数据库、内存数据库（虽然一般用作缓存了），不要说你没有哈，真没有的话，戳<a href="">这里</a>和<a href="">这里</a>看我以前的博客。</p>
<h5 id="tomcat和nginx"><a href="#tomcat和nginx" class="headerlink" title="tomcat和nginx"></a>tomcat和nginx</h5><p>这两个家伙不比上头的数据库们罕见。其实一开始我还奇怪，为什么要同时使用两个web服务器，后来了解到，这是做法叫做“动静分离”，静态web资源依靠nginx，动态依靠tomcat，毕竟nginx在渲染静态资源时效率真的要高出不少。两者的安装和配置请戳<a href="">这里</a>和<a href="">这里</a>。</p>
<h5 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h5><p>最后这个嘛，对分布式、高可用等概念稍微有一点了解的同学应该都听说过，本文暂时不会对它做深入的解释，它的安装，毕竟是可以通过ubuntu的软件源来完成的，方便了不少呢<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># zk需要java环境，一般地，openjdk可以代替oracle jdk</div><div class="line">apt install openjdk-8-jdk</div><div class="line"></div><div class="line"># zookeeperd用于提供zk的启动脚本，从而以服务形式管理zk</div><div class="line">apt install zookeeper zookeeperd</div></pre></td></tr></table></figure></p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>其实这个副标题不是那么恰当，这一步要完成的是下载disconf-web并且修改它的配置文件来适应前边安装好的以来组件。disconf下载有那么一丁点特殊，它没有提供单独的下载地址，既然是github上的一个项目，直接clone吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/knightliao/disconf.git</div></pre></td></tr></table></figure></p>
<p>然后打开./disconf-web/profiles/rd目录，其中有</p>
<ul>
<li>application.properties</li>
<li>jdbc-mysql.properties</li>
<li>log4j.properties</li>
<li>logback.xml</li>
<li>redis-config.properties</li>
<li>zoo.properties</li>
</ul>
<p>共6个文件就是disconf的配置文件，我们需要依次修改。</p>
<h5 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h5><p>首先这个文件是由application-demo.properties重命名而来的，这里边配置的是服务器域名和邮件通知功能。服务器域名，官方文档上说要和后边nginx里的配置保持一致。</p>
<h5 id="jdbc-mysql-properties-amp-redis-config-properties"><a href="#jdbc-mysql-properties-amp-redis-config-properties" class="headerlink" title="jdbc-mysql.properties &amp; redis-config.properties"></a>jdbc-mysql.properties &amp; redis-config.properties</h5><p>这两个文件看名字猜也猜得到，配置mysql和redis的，我们要修改的主要是如何连接到相应的数据库。另外官方文档要求redis必须配置双实例，就算我们的redis服务单点，也要配置两个。</p>
<h5 id="log4j-properties-amp-logback-xml"><a href="#log4j-properties-amp-logback-xml" class="headerlink" title="log4j.properties &amp; logback.xml"></a>log4j.properties &amp; logback.xml</h5><p>两个日志框架的配置文件，日志格式个人觉得没有什么修改的必要，但我们所有业务有统一的日志路径，所以日志路径是要修改的。因为没有细读过disconf的源代码，所以不是很清楚它是同时用了log4j和logback还是咋滴，两个文件中总共配置了3处日志，日志文件名分别是disconf-log4j.log、disconf-web.log和monitor.log。</p>
<h5 id="zoo-properties"><a href="#zoo-properties" class="headerlink" title="zoo.properties"></a>zoo.properties</h5><p>最后这个是zookeeper的配置文件，这个文件原本配置了3台机器组成的zk集群，谁让我们服务都是单点的呢(笑～)，直接改成我们唯一的zk节点的ip和端口。</p>
<p>另外这里有点小问题，此处配置的zk节点信息，client启动时会通过web api去获取和使用，如果我们配置成zk节点的内网ip，那线下可能就访问不到，而如果配置成外网ip，线上使用时所有数据岂不是要到公网上绕一圈？我暂时没有好的办法，配置成了公网ip，再在内网主机的hosts里加一行，强行将公网ip转向内网ip，哪位同学给个更好的解决方案哈～</p>
<h4 id="打包和部署"><a href="#打包和部署" class="headerlink" title="打包和部署"></a>打包和部署</h4><p>disconf提供了一个用于打包自身的脚本：.disconf-web/deploy/deploy.sh，运行脚本前要指定好配置文件的所在路径，以及打包的输出路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 指定配置文件文件所在路径</div><div class="line">ONLINE_CONFIG_PATH=/tmp/disconf/disconf-web/profile/rd</div><div class="line">export ONLINE_CONFIG_PATH</div><div class="line"></div><div class="line"># 指定打包输出路径</div><div class="line">WAR_ROOT_PATH=/tmp/disconf/disconf-web/war</div><div class="line">export WAR_ROOT_PATH</div><div class="line"></div><div class="line"># 执行打包脚本（cd到disconf-web目录下执行）</div><div class="line">sh deploy/deploy.sh</div></pre></td></tr></table></figure></p>
<p>可能要经过一段时间的等待（毕竟要下载不少jar包），打开刚才指定的目录输出路径，可以看到是一个熟悉的web项目的结构。吐槽一句，既然部署脚本已经帮忙把war包给解压了，那为何不好人做到底，把已经没用的war包顺手删掉呢？还有打包时复制过去的配置文件同样也是多余的呀。</p>
<p>在正式部署之前还有一件事要做——初始化数据库，要用到的sql，disconf也都提供好了，位于./disconf-web/sql目录下，包括4个文件，执行的顺序看其中的readme吧。当然，这都是可以修改了，像什么环境啦，用户啦都可以定制得更符合我们的需要，还有许多测试数据可能也是我们不需要的。</p>
<p>初始化好了数据库就可以开始部署了。前面说过，disconf做了动静分离，因此部署分两个部分。先部署动态部分（tomcat），修改tomcat端口为disconf的后端端口号（这里假定本机的tomcat上就跑这么一个应用～），打开配置目录下的server.xml文件，在<host>节点下添加这么一个虚拟主机，映射到站点根目录上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Context path=&quot;&quot; docBase=&quot;/opt/disconf&quot; /&gt;</div></pre></td></tr></table></figure></host></p>
<p>再部署静态部分（nginx），同样假定本机的nginx只被disconf使用，因此直接修改default站点（/etc/nginx/site-available/default文件）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">	listen 80 default_server;</div><div class="line">	root /opt/disconf/html;</div><div class="line">	index index.html;</div><div class="line">	server_name _;</div><div class="line">	location / &#123;</div><div class="line">		try_files $uri $uri/ =404;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重新启动tomcat和nginx就完成了disconf的部署。注意这里完全将动态资源和静态资源分离了，这是因为我们还有另一台更前置的nginx，根据具体的uri匹配请求的资源应该被反向代理到这里的tomcat还是nginx上，因此如果到这一步要进行测试的话，记得访问动静态资源的端口号是不一样的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[配置ssh端口转发]]></title>
      <url>http://www.lx1992.com.cn/2017/01/11/ssh-port-forwarding/</url>
      <content type="html"><![CDATA[<p>接触linux的同学不可避免地要常常接触ssh，一般地，我们都可以在本地主机（下称<strong>host1</strong>）上通过ssh命令直接连接另一台远程主机（下称<strong>host2</strong>）来执行想要的命令。</p>
<p>但在某些情况下，因为存在防火墙，或者两台主机不在同一个网络，再者其他别的什么原因，可能我们无法直接从host1登录host2。</p>
<a id="more"></a>
<p>要解决这个问题，办法也不少，比方说在防火墙上打个洞，至少把host2的主机的ssh端口暴露出来，当然，这一般不是我们所期望的解决方案；更为常见的办法，是再找一台既能够被host1访问，又能够被host2访问的主机（下称<strong>host3</strong>）用作跳板，从而间接实现host1登录host2。&lt;!–，示意图如下</p>
<p><img src="?" alt="">–&gt;</p>
<p>要实现这个效果，办法又有不止一种，之前也介绍过<a href="/2016/12/30/port-mapping-by-iptables/">用iptables实现端口映射</a>，本文则主要讲讲如何用ssh的“端口转发”（Port Forwarding）功能实现类似的效果。</p>
<p>ssh的端口转发分为3种，本地转发、远程转发和动态转发。</p>
<h4 id="本地转发"><a href="#本地转发" class="headerlink" title="本地转发"></a>本地转发</h4><p>用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -L [&lt;local host&gt;:]&lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;ssh host&gt;</div></pre></td></tr></table></figure></p>
<p>例如，在host1上执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -L 7001:&lt;host2&gt;:8001 &lt;host3&gt;</div></pre></td></tr></table></figure></p>
<p>即可建立host1到host3的ssh连接，并在host1上监听7001端口，将到达此端口的数据，通过host3，转发到host2的8001端口上。</p>
<p>注意一点，host1默认只在本地回环的7001端口上监听，所以从host1以外的主机是无法使用这个本地转发的，如果需要别的机器使用，有两种办法：一是带上常被忽略的[<local host="">:]参数，并且写成0.0.0.0来监听host1所有网卡；二是带上-g参数，顺带着补充几个ssh常见的参数：-f后台运行，-C压缩数据，-N不执行命令。</local></p>
<h4 id="远程转发"><a href="#远程转发" class="headerlink" title="远程转发"></a>远程转发</h4><p>用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -R [&lt;local host&gt;:]&lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;ssh host&gt;</div></pre></td></tr></table></figure></p>
<p>首先要想想为什么会有远程转发的存在。很多时候，我们的host3面临这样一种境地，它可以访问外网，但外网不能访问它，最常见的就是host3位于nat路由之后的情形。这种情况下本地转发就失效了，此时需要host3反过来主动建立到host1的连接，应当在host3上执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -R 7002:&lt;host2&gt;:8002 &lt;host1&gt;</div></pre></td></tr></table></figure></p>
<p>类比本地转发，这次建立的是host3到host1的ssh连接，并在host3上监听7002端口，将到达此端口的数据，转发到host2的8002端口上。</p>
<p>有点晕？其实本地转发和远程转发两者最显著的差异在于一开始host1和host3建立ssh连接的方向，谁是ssh client，谁是ssh server，其他数据流的方向是一样的。如果这个ssh连接的方向，和端口转发的方向一致，那么就是“本地转发”，否则是“远程转发”。假如host1和host3之间本身就可以互相访问，那这两种转发用哪一种都可以。</p>
<h4 id="动态转发"><a href="#动态转发" class="headerlink" title="动态转发"></a>动态转发</h4><p>用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -D [&lt;local host&gt;:]&lt;local port&gt; &lt;ssh host&gt;</div></pre></td></tr></table></figure></p>
<p>最后这个动态转发和前面两者不太一样，无论本地转发还是远程转发，都要指定怎么转发，但有时候这个不是我们一开始就能确定的。其实，在动态转发中，ssh扮演了SOCKS(5)代理的角色，具体实现是SOCKS协议的事了，超出了本文的范畴。如果你在host1上执行了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -D 9001 &lt;host3&gt;</div></pre></td></tr></table></figure></p>
<p>那么host1上的其他应用就可以设置127.0.0.1:9001作为自己的SOCKS(5)代理服务器了。</p>
<h4 id="实现连接维持"><a href="#实现连接维持" class="headerlink" title="实现连接维持"></a>实现连接维持</h4><p>不知道各位看官发没发现一个问题，上面的所有操作，都是基于事先建立好的一个ssh连接之上的，但连接毕竟是连接啊，谁知道啥时候就断了呢？万一连接断了，岂不是又要我们人工登录上去重新配一次端口转发，这多麻烦！这时就可以请出autossh这货了。它是干啥滴？</p>
<blockquote>
<p>autossh is a program to start a copy of ssh and monitor it, restarting it as necessary should it die or stop passing traffic.</p>
</blockquote>
<p>man一下，说的很清楚，它用来启动一个ssh连接并监视它，一旦它挂了就重启它。具体的原理呢，就是在建立ssh连接的2台主机之间再建立1个用于监视的连接，而这个连接上定期有测试数据传送。</p>
<p>啊，别问我如果这个监视的连接也挂了该怎么办。。。而且理论上，如果建立ssh连接的时候附带着执行一条会定期产生数据传送的命令，应该也可以实现类似的效果吧？</p>
<p>至于使用，autossh主要就多了一个-M参数，指定2个端口号，分别用于监视数据的发送和接收，如果只指定了其一，另一个自动取给定的这个端口号+1；至于-f参数，我又在这里踩坑了，也是看了帮助文档以后才知道，虽然和ssh里的-f一样都是使命令在后台运行，但给autossh加上-f可能会导致ssh无法输入密码什么的，所以这个参数放在ssh里头好了。</p>
<p>举个栗子，autossh的用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">autossh -M 4444 -gNfL 2222:192.168.1.102:3333 user@192.168.1.103</div></pre></td></tr></table></figure></p>
<p>就可以实现“在后台建立到192.168.1.103的ssh连接，不执行命令但用于将到达本机2222端口的数据转发到192.168.1.102的3333端口，而且它是可被共享的；另外通过4444和4445端口监视这个ssh连接的存活状况，如果发生异常会自动重连”。对了，最好将autossh添加到开机启动里头哦，否则机器一重启，我们的配置又没有了。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/" target="_blank" rel="external">实战 SSH 端口转发</a><br><a href="https://blog.twofei.com/528/" target="_blank" rel="external">SSH的三种端口转发（Port forwarding）</a><br><a href="http://www.cnblogs.com/eshizhan/archive/2012/07/16/2592902.html" target="_blank" rel="external">SSH反向连接及Autossh</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用Postfix实现通过外部SMTP服务转发邮件]]></title>
      <url>http://www.lx1992.com.cn/2017/01/10/send-mail-using-external-smtp-by-postfix/</url>
      <content type="html"><![CDATA[<p>项目中许多地方都需要邮件通知功能。以开发工具为例，譬如，Gogs在版本库变化时可以通知团队成员、Redmine在项目（任务）进度变化时也有类似的功能，更进一步地，程序上线后将会配置相应的JVM监控，以便于发生线上故障时（程序抛出非预期的异常等）及时通知开发者处理。</p>
<a id="more"></a>
<p>但是，有几个问题需要留意。首先是如何发送邮件？自己搭建一套完整的邮件服务？真的这样做的话，可以以类似<a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#109;&#97;&#105;&#108;&#x40;&#x6d;&#x79;&#100;&#x6f;&#x6d;&#97;&#105;&#110;&#46;&#99;&#111;&#109;">&#109;&#97;&#105;&#108;&#x40;&#x6d;&#x79;&#100;&#x6f;&#x6d;&#97;&#105;&#110;&#46;&#99;&#111;&#109;</a>的名义发送邮件，看上去是逼格满满，可就算不考虑这个操作的复杂性，在这个垃圾邮件泛滥的时代，十有八九这种自己发送的邮件会面临各种限制。再者，更现实一点，这些程序都运行在内网主机上，如何向外部发送邮件呢？</p>
<p>其实，使用邮件中继转发（relay）服务就可以完全解决上面这些所谓的“问题”。邮件中继转发，简单地说，就是邮件的最终递送仍旧由外部SMTP服务完成，163、QQ、Gmail什么的都可以，他们不是更专业吗？而我们的邮件服务器只是扮演一个代理的作用而已。</p>
<p>肩负邮件中继转发这一使命的，也就是本文的主角——Postfix。想要详细学习了解的同学可以戳<a href="https://en.wikipedia.org/wiki/postfix_(software" target="_blank" rel="external">这里</a>)。在本例中，我们的程序将要发送的邮件交给Postfix，然后就没有然后了，完全不知道，也不需要知道邮件最后怎么样了。而收到邮件的Postfix，就像我们在邮件客户端（Foxmail、Thunderbird等）里点击“发送”按钮一般，将邮件交由配置好的外部SMTP服务。</p>
<p>下面直接介绍开始配置的过程。</p>
<h4 id="安装Postfix"><a href="#安装Postfix" class="headerlink" title="安装Postfix"></a>安装Postfix</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt install postfix</div></pre></td></tr></table></figure>
<p>安装过程中有3次同用户的交互。</p>
<p>首先是询问你邮件服务器类型，网上大部分资料，选择的都是Internet site，但其实，纯粹用作邮件中继转发，选择Satellite system就可以了。<br><img src="/images/a1ebbc6e-02eb-4aaf-8700-024041115cdc.png" alt=""></p>
<p>然后是设置邮件域名，这里Postfix默认填入了主机名，因为不是直接通过我们的主机对外发送邮件，这一步的意义似乎没有网上教程说的那么邪乎，还要配置DNS的MX记录的。<br><img src="/images/c6502464-9389-4509-9f41-762ac25f7595.png" alt=""></p>
<p>最后是设置Postfix将收到的邮件中继转发给谁，也就是外部SMTP服务器的地址，本例中我们使用阿里云邮，按照它的说明，这里应该填入[smtp.aliyun.com]:465。<br>注意：如果第一步选择了Internet site，那么这一步就不会出现了，可以在安装完成后直接去修改配置文件。<br><img src="/images/426ecca3-a035-4a57-9c8d-661c5171ec9e.png" alt=""></p>
<h4 id="配置main-cf"><a href="#配置main-cf" class="headerlink" title="配置main.cf"></a>配置main.cf</h4><p>Postfix的主要配置文件为main.cf和master.cf，其中后者一般可以直接保持默认，配置邮件中继转发服务仅需要修改前者，vim打开这个文件，找到其中这几行（没有的话就自己加上），并且修改等号后面的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">inet_interfaces = all</div><div class="line">inet_protocols = ipv4</div><div class="line">mynetworks_style = subnet</div><div class="line">mynetworks = 127.0.0.0/8, 192.168.207.0/24</div><div class="line"></div><div class="line">smtpd_use_tls = no</div><div class="line"></div><div class="line">relayhost = [smtp.****.com]:465</div><div class="line">smtp_sasl_auth_enable = yes</div><div class="line">smtp_sasl_password_maps = hash:/etc/postfix/sasl_passwd</div><div class="line">smtp_sasl_security_options = noanonymous</div><div class="line"></div><div class="line">smtp_use_tls = no</div><div class="line">smtp_tls_wrappermode = yes</div><div class="line">smtp_tls_security_level = encrypt</div></pre></td></tr></table></figure></p>
<p>可能这个地方又和网上的教程不太一致了，但也是博主自己反复踩坑、修改文件后得出的一组能够正常工作的配置。</p>
<p>inet_interfaces：配置Postfix监听的网卡，常见的选项包括all和loopback-only，当然也可以指定具体的IP+端口号，但官方的建议是这个选项直接保持默认，因为还有许多别的途径可以满足类似的需求。</p>
<p>inet_protocols：配置Postfix使用的网络协议，毕竟在我国ipv6只用在教育网，直接把这项配置成ipv4还可以免去诸如::1这样的IP地址出现。</p>
<p>mynetworks：配置Postfix可信任的客户端，本例中采用了CIDR写法，对来源是本机，或者本机所在局域网（192.168.207.0网段）的邮件才予以中转。这个和mynetworks_style是相呼应的，一般设置这个即可。</p>
<p>smtpd_use_tls：这个的缺省值是yes，并且还配置了证书，但估计就是证书的问题，发送邮件时报了一个关于证书的错误。考虑到我们搭建的是close relay且仅在内部使用，对安全性要求没那么高，直接关掉这个选项了事。</p>
<p>relayhost：这个应该在安装的第三步已经配置过了，当时没配的，这里补上吧。</p>
<p>smtp_sasl打头的3个选项：分别用于配置外部smtp服务是否需要授权？授权信息保存在哪？有哪些授权限制？答案是当然需要授权、授权信息保存在/etc/postfix/sasl_passwd中（后面会单独配置）、不允许匿名登录。</p>
<p>smtp_use_tls：这个的缺省值也是yes，按照我所使用的外部smtp服务方的说明，应该是要启用这个选项了，但是一旦启用就提示connection time out，也不像是证书又惹祸了，知道原因的同学可以说一声呀。</p>
<p>smtp_tls打头的2个选项：这最后2个原本我是没有配置的，网上的教程似乎也没提及，但是配置成功、发送邮件时有个警告，建议我加上，那就加上吧……</p>
<h4 id="配置sasl-passwd"><a href="#配置sasl-passwd" class="headerlink" title="配置sasl_passwd"></a>配置sasl_passwd</h4><p>前面提到过，关于外部SMTP服务授权相关的信息保存在sasl_passwd中，按照官方的建议，我们创建/etc/postfix/sasl_passwd文件，并在其中填入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$relayhost username:password</div></pre></td></tr></table></figure></p>
<p>注意：这个relayhost和main.cf中的必须一致（所以我给加了个$符），毕竟要建立映射关系的。我在这里踩了两次坑，第一次是两个地方配置不一致，第二次是密码居然输错了……报错前者是“需要认证”，后者是“认证失败”，因此耽搁了一点时间。</p>
<p>然后转换成Postfix需要的hash格式（生成sasl_passwd.db文件）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">postmap /etc/postfix/sasl_passwd</div></pre></td></tr></table></figure></p>
<p>注意：我们将邮箱密码明文保存在sasl_passwd中了，出于安全性考虑，建议将这个文件的权限设置成只有root用户可读。</p>
<h4 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h4><p>至此，Postfix的配置就完成了，重启之。嗯，其实Postfix提供了重新载入配置文件的方法，很多时候并不需要重启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">postfix reload</div></pre></td></tr></table></figure></p>
<p>莫忘了把我们的程序中的SMTP服务器填写成“Postfix服务器地址:25”，然后发送一封测试邮件。瞅一眼日志，发送成功！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Jan 10 16:32:02 ubuntu-server postfix/smtp[3946]: 9D6E381168: to=&lt;****@163.com&gt;, relay=smtp.****.com[*.*.*.*]:465, delay=0.5, delays=0/0/0.25/0.25, dsn=2.0.0, status=sent (250 Data Ok: queued as freedom)</div><div class="line">Jan 10 16:32:02 ubuntu-server postfix/qmgr[3942]: 9D6E381168: removed</div></pre></td></tr></table></figure></p>
<p>P.S.日志位于/var/log/mail.log中，Postfix设计的原则就是Linux已经有的，绝不重复造轮子，所以……</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-mail-relay-with-postfix-and-mailgun-on-ubuntu-16-04" target="_blank" rel="external">How to Set Up a Mail Relay with Postfix and Mailgun on Ubuntu 16.04 </a><br><a href="https://www.howtoforge.com/tutorial/configure-postfix-to-use-gmail-as-a-mail-relay/" target="_blank" rel="external">Configure Postfix to use Gmail as a Mail Relay</a><br><a href="https://easyengine.io/tutorials/linux/ubuntu-postfix-gmail-smtp/" target="_blank" rel="external">Configure Postfix to Use Gmail SMTP on Ubuntu</a><br><a href="https://www.linode.com/docs/email/postfix/postfix-smtp-debian7" target="_blank" rel="external">Configure Postfix to Send Mail Using an External SMTP Server</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[搭建Gogs「私有Git版本控制」服务]]></title>
      <url>http://www.lx1992.com.cn/2017/01/06/install-gogs-server/</url>
      <content type="html"><![CDATA[<p>Gogs(Go Git Service)是一款使用Go语言开发，极易以最简单、最快速和最轻松的方式搭建的自助Git服务。</p>
<a id="more"></a>
<p>相比于这个系列下面其他开发工具的安装和配置，gogs还算是比较简单的。另外考虑到建立linux/mysql用户、tar解压缩这一类的简单操作已经重复了太多次，本文就不再重复讲述了。</p>
<p>首先将下载好的安装包解压到/opt目录下，并在mysql中运行scripts子目录下的mysql.sql文件。这步操作实际上就是创建了一个名为gogs、编码为utf8mb4的空数据库，因此也可以自己在mysql中创建。</p>
<p>随后切换回上层目录（/opt/gogs），运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./gogs web</div></pre></td></tr></table></figure></p>
<p>即可使用 <a href="http://ip:3000" target="_blank" rel="external">http://ip:3000</a> 访问gogs服务，进行进一步的安装和配置，包括gogs运行环境、数据库、管理员账户等。</p>
<p>到此为止，gogs的安装和配置基本上就完成了，但还是以普通进程方式运行的，我们还应当配置为以<a href="">服务</a>或<a href="">守护进程</a>的方式运行，保证gogs服务开机自启动且稳定运行。</p>
<p>这就完了？！我自己都觉得这次写的好水啊……</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[重置MySQL服务器]]></title>
      <url>http://www.lx1992.com.cn/2017/01/03/reset-mysql-server/</url>
      <content type="html"><![CDATA[<p>也不知道是造了什么虐，昨天搭建好的MySQL服务器今天竟然挂了。。。无奈又写了这篇。这篇文章主要包括两个部分，一是如何重置root密码，二是如何直接重建整个数据库。除非遇到一些比较极端的情况，否则所述的内容可能不会很常用。</p>
<a id="more"></a>
<h4 id="1-重置root密码"><a href="#1-重置root密码" class="headerlink" title="1. 重置root密码"></a>1. 重置root密码</h4><p>重置密码的步骤从网络上的资料看五花八门，所以还是参考<a href="http://dev.mysql.com/doc/refman/5.7/en/resetting-permissions.html" target="_blank" rel="external">官方指南</a>更靠谱。</p>
<p>这个教程给出了3种方案，说是分别对应Windows系统、(类)Unix系统，和通用方案。我采用了其中的“通用方案”，总共分为6个步骤。</p>
<h5 id="1-1-停止mysql服务"><a href="#1-1-停止mysql服务" class="headerlink" title="1.1 停止mysql服务"></a>1.1 停止mysql服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service mysql stop</div></pre></td></tr></table></figure>
<h5 id="1-2-加上参数–skip-grant-tables重启mysql服务"><a href="#1-2-加上参数–skip-grant-tables重启mysql服务" class="headerlink" title="1.2 加上参数–skip-grant-tables重启mysql服务"></a>1.2 加上参数–skip-grant-tables重启mysql服务</h5><p>这个是需要以安全模式直接启动mysqld守护，因此和大多数情况下用service操作不太一样。如果不愿意这么做，也可以把这个参数直接加进配置文件里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[mysqld]</div><div class="line"># 加上这么一行，其他配置保持不变</div><div class="line">skip-grant-tables</div></pre></td></tr></table></figure></p>
<p>教程中还建议一并加上–skip-networking参数。因为在skip-grant-tables模式下，mysql不需要输入密码就可以登录，这是相对不安全的，skip-networking可以阻止通过网络访问mysql。</p>
<h5 id="1-3-直接登录mysql"><a href="#1-3-直接登录mysql" class="headerlink" title="1.3 直接登录mysql"></a>1.3 直接登录mysql</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -uroot</div></pre></td></tr></table></figure>
<h5 id="1-4-重置密码"><a href="#1-4-重置密码" class="headerlink" title="1.4 重置密码"></a>1.4 重置密码</h5><p>因为skip-grant-tables的原因，alter user、set password等操作都会被拒绝，教程里仍然提到了这个办法，可能是兼容性的考虑吧。</p>
<p>此时要修改密码，可以直接修改user表，注意保存密码的字段已经不是老教程里说的password了，而是authentication_string。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 切换数据库</div><div class="line">use mysql;</div><div class="line"></div><div class="line"># 更新密码字段</div><div class="line">update user set authentication_string = password(&apos;&lt;new_password&gt;&apos;) where user = &apos;root;</div><div class="line"></div><div class="line"># 刷新权限</div><div class="line">flush privileges;</div></pre></td></tr></table></figure></p>
<h5 id="1-5-恢复配置并重启服务"><a href="#1-5-恢复配置并重启服务" class="headerlink" title="1.5 恢复配置并重启服务"></a>1.5 恢复配置并重启服务</h5><p>就是删除或者注释掉刚加在配置文件里的skip-grant-tables，然后按照正常的方式重新启动mysql服务。</p>
<h5 id="1-6-用新密码登录mysql"><a href="#1-6-用新密码登录mysql" class="headerlink" title="1.6 用新密码登录mysql"></a>1.6 用新密码登录mysql</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -uroot -p</div></pre></td></tr></table></figure>
<p>登录成功，但是执行任何操作都提示需要“重置密码”，不过这次就可以使用正常的方式修改密码了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 适合5.7.6及以后版本</div><div class="line">alter user &apos;root&apos;@&apos;localhost&apos; identified by &apos;&lt;new_password&gt;&apos;</div><div class="line"></div><div class="line"># 适合5.7.5及以前版本</div><div class="line">set password for &apos;root&apos;@&apos;localhost&apos; = password(&apos;&lt;new_password&gt;&apos;);</div></pre></td></tr></table></figure></p>
<h4 id="2-重建整个数据库"><a href="#2-重建整个数据库" class="headerlink" title="2. 重建整个数据库"></a>2. 重建整个数据库</h4><p>需要重建整个数据库的概率应当比重置root密码更低，一般是数据库发生了比较严重的故障或者损坏，且数据都不太重要或者做好了备份的情况下，直接清除掉现有的全部内容，恢复mysql服务到最原始的状态。总共分为4个步骤。</p>
<h5 id="2-1-停止mysql服务"><a href="#2-1-停止mysql服务" class="headerlink" title="2.1 停止mysql服务"></a>2.1 停止mysql服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service mysql stop</div></pre></td></tr></table></figure>
<h5 id="2-2-删除数据目录（data-dir）下的全部文件"><a href="#2-2-删除数据目录（data-dir）下的全部文件" class="headerlink" title="2.2 删除数据目录（data_dir）下的全部文件"></a>2.2 删除数据目录（data_dir）下的全部文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 视data_dir而定</div><div class="line">cd /var/lib/mysql</div><div class="line">rm -rf *</div></pre></td></tr></table></figure>
<p>如果没有做这一步，下一步会提示“数据目录中存在文件，操作失败”</p>
<h5 id="2-3-重建数据库"><a href="#2-3-重建数据库" class="headerlink" title="2.3 重建数据库"></a>2.3 重建数据库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysqld --initialize</div></pre></td></tr></table></figure>
<h5 id="2-4-重启服务"><a href="#2-4-重启服务" class="headerlink" title="2.4 重启服务"></a>2.4 重启服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service mysql start</div></pre></td></tr></table></figure>
<p>注意因为数据库已经被重置了，我也不知道新的root密码是什么了，试了下不是空密码，所以还得乖乖参考上一步，重置下密码。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[配置ssh免密码登录]]></title>
      <url>http://www.lx1992.com.cn/2017/01/02/ssh-public-key-login/</url>
      <content type="html"><![CDATA[<p>绝大多数情况下，我们都是通过ssh登录到云主机的，这个命令就是最最常规的ssh方式登录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh username@hostname</div></pre></td></tr></table></figure></p>
<p>但一般地，线上主机多多少少会有一些额外的登录限制（当然，还是出于安全性的考虑）。常见的限制包括，限制从某些主机登录，限制用ssh密钥而不允许用密码登录等，这篇博客说说如何来配置后一种限制。</p>
<a id="more"></a>
<h4 id="1-配置ssh免密码登录"><a href="#1-配置ssh免密码登录" class="headerlink" title="1. 配置ssh免密码登录"></a>1. 配置ssh免密码登录</h4><p>这一步除了安全性因素外，其实懒也占了挺大一块的，ssh登录在后期是要大量使用的，每次输入密码真的太麻烦，所以在这里配置下ssh免密码登录。</p>
<p>它的原理也很简单，假设要从A机器登录B机器，默认地会要求输入B机器的密码，但如果B机器上有A机器的公钥，就可以跳过这个步骤。所以我们要做的，就是在A机器上生成密钥对，并将其中的公钥提供给B机器。</p>
<h5 id="1-1-在A机器上生成ssh密钥对"><a href="#1-1-在A机器上生成ssh密钥对" class="headerlink" title="1.1 在A机器上生成ssh密钥对"></a>1.1 在A机器上生成ssh密钥对</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa</div></pre></td></tr></table></figure>
<p>运行后一路回车，即可在~/.ssh目录下生成id_rsa和id_rsa.pub两个文件，其中带.pub后缀的就是公钥，另一个是私钥，千万不能泄露哦！</p>
<h5 id="1-2-将公钥传输到B机器"><a href="#1-2-将公钥传输到B机器" class="headerlink" title="1.2 将公钥传输到B机器"></a>1.2 将公钥传输到B机器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp ~/.ssh/id_rsa.pub username@hostname:~/</div></pre></td></tr></table></figure>
<p>其中的username是B机器的用户名，hostname是B机器的主机名或IP地址，这时还是要输入密码的。</p>
<h5 id="1-3-使B机器信任A机器的公钥"><a href="#1-3-使B机器信任A机器的公钥" class="headerlink" title="1.3 使B机器信任A机器的公钥"></a>1.3 使B机器信任A机器的公钥</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</div></pre></td></tr></table></figure>
<p>这里补上后来学到的另一种方案，可以用ssh-copy-id代替scp手动复制文件、cat重定向公钥（即1.2、1.3步）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-copy-id username@hostname</div></pre></td></tr></table></figure></p>
<h5 id="1-4-配置权限"><a href="#1-4-配置权限" class="headerlink" title="1.4 配置权限"></a>1.4 配置权限</h5><p>这一步网上的说法也是必须的，虽然一开始我没有配置这一步也没有出错，但是仔细想想出于安全性的考虑还是做一下为妙。所要完成的任务就是把B机器的.ssh目录权限设置成700（仅用户本人可以读、写、访问）， authorized_keys文件权限设置成600（仅用户本人可以读、写）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod 700 .ssh</div><div class="line">chmod 600 .ssh/authorized_keys</div></pre></td></tr></table></figure></p>
<p>行了！试一下，在A机器上直接ssh username@hostname不再需要输入密码就直接登录了。</p>
<h4 id="2-关闭密码登录"><a href="#2-关闭密码登录" class="headerlink" title="2. 关闭密码登录"></a>2. 关闭密码登录</h4><p>上一步实现了ssh密钥登录，即快捷又方便，那么自然就可以关闭密码登录了。vim打开/etc/ssh/sshd_config文件，找到并修改下面2行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PubkeyAuthentication yes</div><div class="line">PasswordAuthentication no</div></pre></td></tr></table></figure></p>
<p>然后重启一下sshd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service sshd restart</div></pre></td></tr></table></figure></p>
<p>搞定！现在再想使用密码登录会告诉你，不行！安全性进一步提高了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu简单用户管理]]></title>
      <url>http://www.lx1992.com.cn/2017/01/02/user-config-in-ubuntu/</url>
      <content type="html"><![CDATA[<p>系统环境现在已经有了。也是出于成本的考虑吧，目前我们的项目会在一台主机上搭建多个服务，以部署开发工具的那台云主机为例，就包括git、maven、sonarqube等。</p>
<p>而linux本身作为一个多用户、多任务的系统，从减少耦合的角度看吧，也应该为每一个应用创建一个用户（话说没有人会希望一个简简单单的操作用的都是root用户吧）。</p>
<a id="more"></a>
<h4 id="1-创建用户"><a href="#1-创建用户" class="headerlink" title="1. 创建用户"></a>1. 创建用户</h4><p>在ubuntu系统中创建用户需要这么几个步骤。这里假设我们都能分清用户、用户组等概念了。首先是添加用户组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo groupadd &lt;groupname&gt;</div></pre></td></tr></table></figure></p>
<p>这样就添加了一个名为groupname的用户组。而后是添加用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo useradd &lt;username&gt; -g &lt;groupname&gt; -m</div></pre></td></tr></table></figure></p>
<p>这样就添加了一个名为username的用户，参数-g表示把新增加的用户添加到groupname用户组，-m表示为新增加的用户创建家目录。</p>
<p>最后当然要设置一个密码，输入下面这个命令，回车后输入2次username用户的新密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo passwd &lt;username&gt;</div></pre></td></tr></table></figure></p>
<p>上面这种是比较常规的方法，ubuntu系统中还有一个命令可以一次性完成这3个步骤<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adduser &lt;username&gt;</div></pre></td></tr></table></figure></p>
<p>不就是把useradd的2个单词反一下嘛～接下来具体的操作这个命令的提示得很完善了。</p>
<h4 id="2-赋予新用户sudo权利"><a href="#2-赋予新用户sudo权利" class="headerlink" title="2. 赋予新用户sudo权利"></a>2. 赋予新用户sudo权利</h4><p>用户也已经添加好了，不过当我们切换到username，准备sudo各种命令时会看到提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">username is not in the sudoers file.  This incident will be reported.</div></pre></td></tr></table></figure></p>
<p>网上对此问题的解决方案也是挺多的，什么直接编辑/etc/sudoers，什么visudo，个人觉得更简单的办法是将username一并添加到sudo用户组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gpasswd -a &lt;usrname&gt; sudo</div></pre></td></tr></table></figure></p>
<p>因为/etc/sudoers中有这么一段话<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Allow members of group sudo to execute any command</div><div class="line">%sudo	ALL=(ALL:ALL) ALL</div></pre></td></tr></table></figure></p>
<p>当然用传统的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usermod -aG &lt;groupname&gt; &lt;username&gt;</div></pre></td></tr></table></figure></p>
<p>也是阔以的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[上美团云Ubuntu主机咯]]></title>
      <url>http://www.lx1992.com.cn/2017/01/02/install-ubuntu-on-mos/</url>
      <content type="html"><![CDATA[<p>其实我一直挺纠结这标题的，要不要这么高调嘛……况且原本的标题是《美团云Ubuntu主机折腾记》，可仔细想，我折腾啥子了？！明明就是几个配置好不啦。</p>
<p>言归正传，项目中会用到数台云主机，今天终于鼓起勇气下了单。当然出于复杂性的考虑，这些云主机的操作系统没有采用线上更常见的CentOS，转向更为寻常的Ubuntu，当然是没有GUI的Server版。</p>
<a id="more"></a>
<p>云主机创建好以后，观察了一下，美团云这系统模板做的还是不错的，基本上可以立即使用，有一些小的点稍稍处理下也不会耽误太多的时间。</p>
<p>首先是语言环境，系统默认的是en_US.UTF-8，似乎改成中文也没有什么不妥的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dpkg-reconfigure locales</div></pre></td></tr></table></figure></p>
<p>运行后会出现一个向导，第一步是选择需要支持的语言环境，默认只选中了en_US.UTF-8，要把zh_CN.UTF-8也一并勾上；第二步是选择默认的语言环境，同样选择zh_CN.UTF-8。OK，等待配置完成。</p>
<p>默认的语言环境配置成中文后，直接从tty登录会看到大量口口口，其实就是中文乱码了，解决的办法也不是没有，把这段脚本加到bash_profile里即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if [ $TERM == &quot;linux&quot; ] &amp;&amp; [ !-e $SSH_TTY ]; then</div><div class="line">    export LANG=&quot;en_US.UTF-8″</div><div class="line">    export LANGUAGE=&quot;en_US.UTF-8″</div><div class="line">fi</div></pre></td></tr></table></figure></p>
<p>不过绝大多数情况下我们都是用ssh登录，这一步其实可做可不做了。网上的另一种说法是通过安装zhcon临时解决，这是一个类似ucdos的插件，从理论上说，对性能会在一定程度的影响。</p>
<p>然后还需要配置下时区，这个系统模板默认的时区是美国时间，和北京时间差了13小时，每次看时间都要做下转换也是不爽<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dpkg-reconfigure tzdata</div></pre></td></tr></table></figure></p>
<p>在这个向导中选择亚洲（Asia）–&gt;上海（Shanghai），OK，这下时间对上了。</p>
<p>最后一步，更新下系统吧，把Linux包管理的特性利用起来，再说线上主机，基本的安全性还是要保证的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt update</div><div class="line">apt upgrade</div></pre></td></tr></table></figure></p>
<p>相信这两个命令没有同学说不知道了吧[微笑]</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu设置全局代理]]></title>
      <url>http://www.lx1992.com.cn/2017/01/01/set-global-proxy-in-ubuntu/</url>
      <content type="html"><![CDATA[<p>之前有一篇文章用iptables做端口映射，实现了从外网直接ssh连接一台内网云主机，但即便这样，还是存在一些问题，譬如，apt仍旧无法访问外部源。</p>
<p>至于原因哈，猜一个，因为前面配置端口转发的时候只映射了22端口，而更新软件源等，使用的是http的80端口，些许应该再配置下http的80端口、https的433端口……</p>
<p>一不做二不休，直接在外网主机上用squid架设代理服务器，不就免去这一切乱七八糟的事了吗？架设代理服务器的过程后面会补上（又给自己挖坑呢）<!--可以看[我的另一篇博客]()，当然是参考了[这篇文章]()-->。</p>
<a id="more"></a>
<p>配置好代理服务器后，自然要把内网主机的代理配置指向这台外网主机。谷歌了一下，大部分文章提到的3种办法。一是直接执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export http_proxy=“proxy_username:password@ip:port”</div></pre></td></tr></table></figure></p>
<p>（这只针对当前会话有效）；二是把上述内容添加到~/.bashrc中（实现当前用户每次登录时生效）；三是安装一些第三方工具，类似于proxychain之类的。</p>
<p>但做了配置之后（不过我只试验了前2种），的确可以使用curl、wget等访问http资源了，但apt还是无法访问外部源，而且配置生效的范围相对局限。这又如何解决呢？</p>
<p>突然想到安装了gui的ubuntu，可以在系统设置中配置全局代理，遂找了个有gui的虚机试验了一把，果然发现配置生效后有两个文件发生了变化，打开具体看一眼，内容是这样滴<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># /etc/environment</div><div class="line"></div><div class="line">http_proxy=&quot;http://192.168.128.129:3128/&quot;</div><div class="line">https_proxy=&quot;https://192.168.128.129:3128/&quot;</div><div class="line">ftp_proxy=&quot;ftp://192.168.128.129:3128/&quot;</div><div class="line">socks_proxy=&quot;socks://192.168.128.129:3128/&quot;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># /etc/apt/apt.conf</div><div class="line"></div><div class="line">Acquire::http::proxy &quot;http://192.168.128.129:3128/&quot;;</div><div class="line">Acquire::https::proxy &quot;https://192.168.128.129:3128/&quot;;</div><div class="line">Acquire::ftp::proxy &quot;ftp://192.168.128.129:3128/&quot;;</div><div class="line">Acquire::socks::proxy &quot;socks://192.168.128.129:3128/&quot;;</div></pre></td></tr></table></figure>
<p>这么看来，前者配置的是系统全局代理服务器，后者则是针对apt做了单独的配置，<a href="http://wiki.ubuntu.org.cn/UbuntuHelp:AptGet/Howto/zh#.E4.B8.BAapt-get.E8.AE.BE.E7.BD.AEhttp.E4.BB.A3.E7.90.86" target="_blank" rel="external">这篇文章</a>也应征了这个说法（ubuntu 10.10以后apt代理从后一个文件中读取）。</p>
<p>好了，将这两个文件新增的内容拷贝出来，贴到需要配置全局代理的内网主机的相同文件中去吧！</p>
<h5 id="2017-01-14补充"><a href="#2017-01-14补充" class="headerlink" title="2017-01-14补充"></a>2017-01-14补充</h5><p>除了apt，发现mvn也不走系统全局代理（捂脸）……</p>
<p>maven的代理配置位于setting.xml文件中的<proxy>节，看着修改下host和port就可以了，说起来也蛮简单的。</proxy></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[搭建MySQL服务器]]></title>
      <url>http://www.lx1992.com.cn/2017/01/01/install-mysql-server/</url>
      <content type="html"><![CDATA[<p>不论是即将开发的程序，还是开发过程中必不可少的git、wiki等工具，它们都需要用数据库来保存自身的数据，所以搭建服务器的第一步自然是先把mysql搭起来。</p>
<a id="more"></a>
<h4 id="1-安装mysql-server"><a href="#1-安装mysql-server" class="headerlink" title="1. 安装mysql-server"></a>1. 安装mysql-server</h4><p>第一步当然是要安装好mysql-server。虽然通过apt默认源亦可完成安装，但是看<a href="http://dev.mysql.com/downloads/repo/apt/" target="_blank" rel="external">mysql官方说明</a>推荐用他们的源，就照着办吧！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 切到/tmp目录，下载官方apt源的配置文件并安装</div><div class="line">cd /tmp</div><div class="line">wget http://dev.mysql.com/get/mysql-apt-config_0.8.1-1_all.deb</div><div class="line">dpkg -i mysql-apt-config_0.8.1-1_all.deb</div><div class="line"></div><div class="line"># 更新软件源，安装mysql-server</div><div class="line">apt update</div><div class="line">apt install mysql-server</div></pre></td></tr></table></figure>
<p>配置源的时候会问你想安装哪些组件、什么版本，作为服务器，只需要安装mysql-server，而出于稳定性考虑，选择5.7的稳定版本；安装的过程中，会要求输入数据库root用户的密码，总共就这2步操作～</p>
<h4 id="2-修改数据库端口和路径"><a href="#2-修改数据库端口和路径" class="headerlink" title="2. 修改数据库端口和路径"></a>2. 修改数据库端口和路径</h4><p>刚刚安装好的mysql-server有一些配置可能不完全适用于我们的环境，因此需要修改一下，主要是数据库端口和路径。修改配置之前需要先停止mysql服务，顺带着复习下服务的简单操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 启动mysql服务</div><div class="line">service mysql start</div><div class="line"></div><div class="line"># 停止mysql服务</div><div class="line">service mysql stop</div><div class="line"></div><div class="line"># 查看mysql服务当前状态</div><div class="line">service mysql status</div></pre></td></tr></table></figure></p>
<h5 id="2-1-配置文件在哪"><a href="#2-1-配置文件在哪" class="headerlink" title="2.1 配置文件在哪"></a>2.1 配置文件在哪</h5><p>网上说，mysql默认从这4个地方寻找配置文件，以先找到的为准，而ubuntu系统中，配置文件默认是下面的第2个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/etc/my.cnf</div><div class="line">/etc/mysql/my.cnf</div><div class="line">/usr/etc/my.cnf</div><div class="line">~/.my.cnf</div></pre></td></tr></table></figure></p>
<p>但是有点奇怪，打开这第2个文件，里面只有一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!includedir /etc/mysql/conf.d/</div></pre></td></tr></table></figure></p>
<p>字面上的意思应该是加载/etc/mysql/conf.d/下的文件，再打开这个目录，只有一个配置组是[mysql]的空的配置文件。</p>
<p>进一步看了下，真正的配置文件应该是/etc/mysql/mysql.cnf，因为它进一步加载了/etc/mysql/mysql.conf.d/mysqld.cnf文件，而我们要修改的[mysqld]配置组正位于其中。这个问题还待熟悉mysql配置的同学解释下哈。</p>
<h5 id="2-2-修改数据库端口"><a href="#2-2-修改数据库端口" class="headerlink" title="2.2 修改数据库端口"></a>2.2 修改数据库端口</h5><p>mysql默认监听3306端口，这是大多数人都知道的。但是呢，出于安全考虑，线上服务基本上不会保持默认端口，甚至都不会开启这附近的端口区间。要修改这个默认监听的端口，只需要修改（添加）port配置项等号后面的数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">port            = 10086</div><div class="line">bind-address	= 0.0.0.0</div></pre></td></tr></table></figure></p>
<p>顺带着地，把bind-address配置项也修改一下，它的默认值是localhost，也就意味着只能从本机连接到mysql服务，这不符合我们的需求，将它改成上面的0.0.0.0即放开这个限制。</p>
<h5 id="2-3-修改数据库路径"><a href="#2-3-修改数据库路径" class="headerlink" title="2.3 修改数据库路径"></a>2.3 修改数据库路径</h5><p>mysql默认将数据库及自身的许多重要文件放置在/var/lib/mysql这个目录下，对大多数云主机来说，这个目录就位于系统盘中，这样即不方便也不安全，再者我们的云主机都购买了数据盘呢，显然应该将这个目录移出来。</p>
<p>如果不放心到底是不是这个目录，可以登录mysql命令行，运行一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show variables like &apos;%dir%&apos;;</div></pre></td></tr></table></figure></p>
<p>其中data_dir变量的值就是当前数据库的路径。</p>
<p>接着即可修改配置文件中的data_dir配置项了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">datadir		= /data/mysql</div><div class="line">log-error	  = /data/logs/mysql/error.log</div></pre></td></tr></table></figure></p>
<p>顺带着的，可以将log的路径也修改一下。修改完路径别忘了把已有的文件复制过去，复制的时候千万留意权限的变化。</p>
<h4 id="3-踩坑时间"><a href="#3-踩坑时间" class="headerlink" title="3. 踩坑时间"></a>3. 踩坑时间</h4><p>敲！黑！板！以为这样就万事大吉，可以重启服务了？嗯，重启是没报错，可是配置也没有生效啊……</p>
<h5 id="3-1-那啥AppArmor"><a href="#3-1-那啥AppArmor" class="headerlink" title="3.1 那啥AppArmor"></a>3.1 那啥AppArmor</h5><p>实话说，我也不知道这是啥，资料显示是ubuntu的一种沙箱机制吧，反正2.3节修改数据库路径的时候，少了这一步可不行（惯性思维了，以前Windows上没这一步），而且就是它导致了没报错、配置却不生效。</p>
<p>一开始我看了<a href="http://blog.csdn.net/qinxiandiqi/article/details/43270147" target="_blank" rel="external">这篇文章</a>，相应地修改了/etc/apparmor.d/usr.sbin.mysqld和/etc/apparmor.d/abstractions/mysql两个文件。</p>
<p>结果好了，启动报错还没有任何日志输出，谷歌一下大部分结果出错的还都是mysqld.service而不是我遇到的mysql.service<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Job for mysql.service failed. See &apos;systemctl status mysqld.service&apos; and &apos;journalctl -xn&apos; for details.</div></pre></td></tr></table></figure></p>
<p>幸运的是后来又找到了<a href="https://www.digitalocean.com/community/tutorials/how-to-move-a-mysql-data-directory-to-a-new-location-on-ubuntu-16-04" target="_blank" rel="external">另一篇文章</a>。这篇文章提到了另一种思路，为数据库路径起个别名，而不是直接改掉路径。</p>
<p>需要修改的文件变成了/etc/apparmor.d/tunables/alias，打开这个文件，赫然发现这么一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Or if mysql databases are stored in /home:</div><div class="line">alias /var/lib/mysql/ -&gt; /data/mysql/,</div></pre></td></tr></table></figure></p>
<p>真的是柳暗花明啊，改之，然后别忘了先重启apparmor服务，后重启mysql服务/。瞄一眼新的数据库路径，文件的修改时间变了，日志也写进来了，Oh yeah~</p>
<h5 id="3-2-登录不了了"><a href="#3-2-登录不了了" class="headerlink" title="3.2 登录不了了"></a>3.2 登录不了了</h5><p>改完了总得测试下吧？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -uroot -p</div></pre></td></tr></table></figure></p>
<p>曾经的mysql&gt;提示符没看到，看到的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR 1698 (28000): Access denied for user &apos;root&apos;@&apos;localhost&apos;.</div></pre></td></tr></table></figure></p>
<p>密码肯定没错，如果本地都不能以root登录，那未必……，更奇怪的是，加上sudo就可以登录，看来是权限又给我桶啥篓子了（所以我说前面复制文件的时候注意权限），可检查了一番似乎又没啥问题</p>
<p>继续谷歌吧，<a href="http://askubuntu.com/questions/766334/cant-login-as-mysql-user-root-from-normal-user-account-in-ubuntu-16-04" target="_blank" rel="external">解决方案</a>这回倒不难找，可人家多是安装了mariadb导致的，我并没有哇！</p>
<p>反正最终的解决方案就是重新建了个root用户，刚好我这边会有多个应用共用一个数据库，为了控制好权限，每个应用有自己的数据库用户名和密码，就当是复习下mysql用户操作了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 删除用户root</div><div class="line">drop user &apos;root&apos;@&apos;localhost&apos;;</div><div class="line"></div><div class="line"># 创建用户root 只允许从localhost登录 密码123456</div><div class="line">create user &apos;root&apos;@&apos;localhost&apos; identified by &apos;123456&apos;;</div><div class="line"></div><div class="line"># 修改root用户密码(直接重置密码后会要求执行以下命令)</div><div class="line">alter user &apos;root&apos;@&apos;localhost&apos; identified by &apos;123456&apos;;</div><div class="line"></div><div class="line"># 赋予用户root全部权限 允许转授权</div><div class="line">grant all privileges on *.* to &apos;root&apos;@&apos;localhost&apos; with grant option;</div><div class="line"></div><div class="line"># 权限立即生效</div><div class="line">flush privileges;</div></pre></td></tr></table></figure></p>
<p>内容就是这些了，如果有同学能帮我解释踩下的几个坑，欢迎留言。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用iptables实现端口映射]]></title>
      <url>http://www.lx1992.com.cn/2016/12/30/port-mapping-by-iptables/</url>
      <content type="html"><![CDATA[<p>按照项目对云主机的规划，只有一台主机具有外网IP（下文称A主机），其他主机都只有内网IP（下文称B主机）。换句话说，只有A主机可以访问外网，B主机不行。虽然这是出于安全性和成本等方面的考虑（数据库、后端接口等不宜暴露），但是这样一来，管理B主机都很成问题了，如何解决呢？</p>
<a id="more"></a>
<p>索性所有云主机将会位于同一个机房，内网是互通的，因此可以在A主机上，用Linux系统的神器iptables配置端口转发，从而实现从外网对B主机的访问。下面的配置都在A主机上完成。</p>
<p>已知A机器内网IP：192.168.1.68，外网IP：10.0.0.9，B机器内网IP：192.168.1.64，要实现设置当外网访问A机器22681端口时转发至B机器22端口，也即可以使用命令直接从外网登录B主机<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -p 22681 username(B)@hostname(A)</div></pre></td></tr></table></figure></p>
<p>首先要启用IPv4转发，打开/etc/sysctl.conf文件，将这一行前的注释符号去掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">net.ipv4.ip_forward=0</div></pre></td></tr></table></figure></p>
<p>保存后不放心的话可以用这个命令检查一下（p=print）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sysctl -p</div></pre></td></tr></table></figure></p>
<p>然后是配置转发，步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#设置将A机器内网22681端口上的请求转发至B机器上</div><div class="line">iptables -t nat -A PREROUTING -d 192.168.1.68 -p tcp –dport 22681 -j DNAT –to-destination 192.168.1.64:22</div><div class="line">#将B机器的应答数据返回至A机器</div><div class="line">iptables -t nat -A POSTROUTING -s 0.0.0.0/0 -p tcp –dport 22 -j SNAT –to-source 192.168.1.68</div></pre></td></tr></table></figure>
<p>最后是保存配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables-save</div></pre></td></tr></table></figure></p>
<p>当然，Linux系统中iptables其实是个很复杂的东西，要不然怎么可以称之为“神器”嘛，前面配置的时候一大堆PREROUTING、POSTROUTING、DNAT、SNAT的本文也没有多做解释，有想要详细了解的，我觉着<a href="http://wwdhks.blog.51cto.com/839773/1154032" target="_blank" rel="external">这篇文章</a>分析的还算详细。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu设置静态IP地址]]></title>
      <url>http://www.lx1992.com.cn/2016/12/25/set-static-ip-in-ubuntu/</url>
      <content type="html"><![CDATA[<p>半年的实习就要结束咯～要回来干活咯～把荒废已久的博客捡起来先～</p>
<p>老板给了个「小」项目，还没买云主机，先在线下用几台VMWare虚机搭建了一个相似的开发环境，然后就发现了个问题——几台虚机都由DHCP分配IP地址，重启时可能会改变，这样就会影响虚机间的通信，因此要给它们设置静态IP地址。</p>
<a id="more"></a>
<p>首先要关闭VMWare的DHCP服务。打开VMWare网络编辑器，因为虚机采用了NAT方式联网，因此找到vmnet8下的use local DHCP service to distribute IP addresses to VMs选项，将其关闭。</p>
<p><img src="/images/0a3f6965-5374-49cc-911d-4daa79341ece.png" alt=""></p>
<p>记得打开NAT Settings界面看下vmnet8的网关，后面的配置中要用到，例如我这里是192.168.207.2。</p>
<p><img src="/images/fe32e386-df43-4760-aaf3-a5213efc3a82.png" alt=""></p>
<p>接着就可以修改虚机网卡的IP地址了。vim打开/etc/network/interface文件，可以看到下面的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># The loopback network interface</div><div class="line">auto lo</div><div class="line">iface lo inet loopback</div><div class="line"></div><div class="line"># The primary network interface</div><div class="line">auto ens33</div><div class="line">iface ens33 inet dhcp</div></pre></td></tr></table></figure>
<p>其中的lo是本地回环，而ens33才是虚机的网卡。修改这个文件：将dhcp改成static，然后加上address、netmask、gateway三个字段，分别用于配置IP地址、子网掩码和网关，配置后类似于这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># The loopback network interface</div><div class="line">auto lo</div><div class="line">iface lo inet loopback</div><div class="line"></div><div class="line"># The primary network interface</div><div class="line">auto ens33</div><div class="line">iface ens33 inet static</div><div class="line">address 192.168.207.128</div><div class="line">netmask 255.255.255.0</div><div class="line">gateway 192.168.207.2</div></pre></td></tr></table></figure>
<p>最后还要修改DNS配置。网上的很多说法是修改/etc/resolv.conf文件，但是打开这个文件就会看到大大的一行</p>
<blockquote>
<p>DO NOT EDIT THIS FILE BY HAND – YOUR CHANGES WILL BE OVERWRITTEN</p>
</blockquote>
<p>哎，人家都让你别改了！</p>
<p>正确的做法应该是修改/etc/resolvconf/resolv.conf.d下的文件。网上的说法是这个目录下有head、tail、base三个文件，但我这只有head和base两个，而且head文件同样标记了不要修改，base是一个空文件。</p>
<p>将base改成下面这样（也就是加上一个或多个nameserver字段，图省事，直接拿了个114的dns）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nameserver 114.114.114.114</div></pre></td></tr></table></figure></p>
<p>最后别忘了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/inid.d/networking restart</div></pre></td></tr></table></figure></p>
<p>重启下网络。OK，大功告成！</p>
]]></content>
    </entry>
    
  
  
</search>
